diff -rupN ns-allinone-2.35-orig/ns-2.35/apps/udp.cc ns-allinone-2.35/ns-2.35/apps/udp.cc
--- ns-allinone-2.35-orig/ns-2.35/apps/udp.cc	2009-06-14 19:35:44.000000000 +0200
+++ ns-allinone-2.35/ns-2.35/apps/udp.cc	2009-11-12 15:43:11.000000000 +0100
@@ -93,7 +93,12 @@ void UdpAgent::sendmsg(int nbytes, AppDa
 
 	double local_time = Scheduler::instance().clock();
 	while (n-- > 0) {
-		p = allocpkt();
+        
+        // Alterated by The Manna Research Group
+        // Used by mannasim - wireless sensor networks simulator.
+		// p = allocpkt(); 
+		p = allocpkt(sizeof(data));
+
 		hdr_cmn::access(p)->size() = size_;
 		hdr_rtp* rh = hdr_rtp::access(p);
 		rh->flags() = 0;
@@ -108,7 +113,10 @@ void UdpAgent::sendmsg(int nbytes, AppDa
 	}
 	n = nbytes % size_;
 	if (n > 0) {
-		p = allocpkt();
+
+		//p = allocpkt(); Alterado pelo grupo Manna
+		p = allocpkt(sizeof(data));
+
 		hdr_cmn::access(p)->size() = n;
 		hdr_rtp* rh = hdr_rtp::access(p);
 		rh->flags() = 0;
diff -rupN ns-allinone-2.35-orig/ns-2.35/common/ns-process.h ns-allinone-2.35/ns-2.35/common/ns-process.h
--- ns-allinone-2.35-orig/ns-2.35/common/ns-process.h	2009-06-14 19:35:44.000000000 +0200
+++ ns-allinone-2.35/ns-2.35/common/ns-process.h	2009-11-12 15:43:11.000000000 +0100
@@ -84,9 +84,22 @@ enum AppDataType {
 	// pub/sub ADU
 	PUBSUB,
 	
-	//Diffusion ADU
+	// Diffusion ADU
 	DIFFUSION_DATA,
 
+	// Inserted by The Manna Research Group
+    // ADUs used by mannasim - wireless sensor networks
+    // simulator.
+    SENSED_DATA, 
+	MANAGEMENT_DATA,
+    
+    ON_DEMAND_DATA,
+	ON_DEMAND_PARAMETER,
+    
+    VIDEO_SENSED_DATA,
+	TEMPERATURE_SENSED_DATA,
+	CARBON_MONOXIDE_SENSED_DATA,
+
 	// Last ADU
 	ADU_LAST
 
@@ -107,6 +120,13 @@ public:
 	// The following two methods MUST be rewrited for EVERY derived classes
 	virtual int size() const { return sizeof(AppData); }
 	virtual AppData* copy() = 0;
+
+    // Inserted by The Manna Research Group
+    // Data functions for On Demand Sensing - these functions should
+    // be overwritten by specific application data types as temperatura
+    // AppData for example.
+    virtual bool compareData(AppData* data, int operation) {return false;}  
+    virtual bool checkEvent(AppData* data_) {return false;}
 };

 diff -rupN ns-allinone-2.35-orig/ns-2.35/mac/mac-802_11Ext.h ns-allinone-2.35/ns-2.35/mac/mac-802_11Ext.h
--- ns-allinone-2.35-orig/ns-2.35/mac/mac-802_11Ext.h	2011-09-08 21:27:26.000000000 +0530
+++ ns-allinone-2.35/ns-2.35/mac/mac-802_11Ext.h	2013-05-10 16:00:39.480499665 +0530
@@ -63,6 +63,8 @@
 #define GET_ETHER_TYPE(x)		GET2BYTE((x))
 #define SET_ETHER_TYPE(x,y)            {u_int16_t t = (y); STORE2BYTE(x,&t);}
 #include "wireless-phyExt.h"
+	// For Mannasim in NS2.35; inserted by Paul S : http://paultsr.in
+#include "cstddef"
 
 /* ======================================================================
  Frame Formats

 diff -rupN ns-allinone-2.35-orig/ns-2.35/linkstate/ls.h ns-allinone-2.35/ns-2.35/linkstate/ls.h
--- ns-allinone-2.35-orig/ns-2.35/linkstate/ls.h	2013-05-10 15:52:51.282177995 +0530
+++ ns-allinone-2.35/ns-2.35/linkstate/ls.h	2013-05-10 16:00:19.344399816 +0530
@@ -133,8 +133,8 @@
 		pair_iterator_bool ib = baseMap::insert(v);
 		return ib.second ? ib.first : baseMap::end();
 	}
-
-	void eraseAll() { erase(baseMap::begin(), baseMap::end()); }
+	// For Mannasim in NS2.35; inserted by Paul S : http://paultsr.in
+	void eraseAll() { this->erase(baseMap::begin(), baseMap::end()); }
 	T* findPtr(Key key) {
 		iterator it = baseMap::find(key);
 		return (it == baseMap::end()) ? (T *)NULL : &((*it).second);



 // Models any entity that is capable of process an ADU. 
diff -rupN ns-allinone-2.35-orig/ns-2.35/common/packet.cc ns-allinone-2.35/ns-2.35/common/packet.cc
--- ns-allinone-2.35-orig/ns-2.35/common/packet.cc	2009-06-14 19:35:44.000000000 +0200
+++ ns-allinone-2.35/ns-2.35/common/packet.cc	2009-11-12 15:43:11.000000000 +0100
@@ -61,6 +61,8 @@ int Packet::hdrlen_ = 0;		// size of a p
 Packet* Packet::free_;			// free list
 int hdr_cmn::offset_;			// static offset of common header
 int hdr_flags::offset_;			// static offset of flags header
+// MIT_uAMPS
+int hdr_rca::offset_;                   // static offset of rca header
 
 
 PacketHeaderClass::PacketHeaderClass(const char* classname, int hdrlen) : 
diff -rupN ns-allinone-2.35-orig/ns-2.35/common/packet.h ns-allinone-2.35/ns-2.35/common/packet.h
--- ns-allinone-2.35-orig/ns-2.35/common/packet.h	2010-05-10 03:58:41.000000000 +0530
+++ ns-allinone-2.35/ns-2.35/common/packet.h	2013-05-10 17:39:07.747508000 +0530
@@ -70,6 +70,10 @@
 //#define HDR_DIFF(p)     (hdr_diff::access(p))  /* SCADD's diffusion ported into ns */
 #define HDR_LMS(p)		(hdr_lms::access(p))
 
+// MIT uAmps
+#define HDR_RCA(p)       ((struct hdr_rca*)(p)->access(hdr_rca::offset()))
+#define HDR_MACSensor(p) ((struct hdr_macSensor*)(p)->access(hdr_mac::offset_))
+
 /* --------------------------------------------------------------------*/
 
 /*
@@ -199,8 +203,12 @@
         // M-DART packets
 static const packet_t PT_MDART = 72;
 	
+	// For Mannasim; inserted by Christian Schultz
+	// For Mannasim in NS2.35; inserted by Paul S : http://paultsr.in
+static const packet_t PT_RCA = 73;
+	
         // insert new packet types here
-static packet_t       PT_NTYPE = 73; // This MUST be the LAST one
+static packet_t       PT_NTYPE = 74; // This MUST be the LAST one
 
 enum packetClass
 {
@@ -417,6 +425,9 @@
 		name_[PT_DCCP_CLOSEREQ]="DCCP_CloseReq";
 		name_[PT_DCCP_RESET]="DCCP_Reset";
 
+		// MIT_uAMPS; For Mannasim; inserted by Christian Schultz
+                name_[PT_RCA] = "rca";
+
 		name_[PT_NTYPE]= "undefined";
 	}
 	static int addPacket(char *name);
@@ -555,6 +566,9 @@
         u_int8_t        incoming;
 
 	//monarch extns end;
+
+	// MIT_uAMPS
+        static void PrintRcHeader(Packet *p, char *layer);
 };
 
 /* 
@@ -670,6 +684,58 @@
 	inline ModulationScheme& mod_scheme() { return (mod_scheme_); }
 };
 
+// MIT_uAMPS
+struct hdr_rca {
+       int msg_type_;
+       char meta_[1000];
+       int meta_size_;
+       float dist_to_dest_;
+       int dist_est_;
+       int rca_mac_src_;
+       int rca_mac_dst_;
+       int rca_link_src_;
+       int rca_link_dst_;
+       int code_;
+       static int offset_;     // offset for this header
+       inline static int& offset() { return offset_; }
+       inline static hdr_rca* access(Packet* p) {
+	       return (hdr_rca*) p->access(offset_);
+       }
+
+/* per-field member functions */
+       inline int& msg_type() { return (msg_type_); }
+       inline int& meta_size() { return (meta_size_); }
+       inline float& get_dist() { return (dist_to_dest_); }
+       inline int& dist_est() { return (dist_est_); }
+       inline void set_meta(const char* data) {
+                meta_size_ = strlen(data);
+                if (meta_size_ > maxmetasize()) {
+	                printf("Error:  Meta size %d too large (max = %d).\n", meta_size_, maxmetasize());
+                  	exit(1);
+                }
+	        memcpy(meta_, data, meta_size_+1);
+	}
+	inline void set_meta(const char * data, int size) {
+		if (size > maxmetasize())
+		{
+			printf("Error: Meta size %d too large (max = %d).\n", size, maxmetasize());
+			exit(1);
+		}
+		memcpy(meta_, data, size);
+		meta_size_ = size;
+	}
+        inline char* const meta() { return (meta_); }
+        inline int maxmetasize() { return (sizeof(meta_)); }
+        inline int& rca_mac_src() { return (rca_mac_src_); }
+        inline int& rca_mac_dst() { return (rca_mac_dst_); }
+	inline int& rca_link_src() { return (rca_link_src_); }
+        inline int& rca_link_dst() { return (rca_link_dst_); }
+        inline int& get_code() { return (code_); }
+        int base_X;
+        int base_Y;
+        inline int& get_base_X() { return (base_X); }
+        inline int& get_base_Y() { return (base_Y); }      
+};
 
 class PacketHeaderClass : public TclClass {
 protected:
@@ -701,6 +767,11 @@
 		assert(p->data_ == 0);
 		p->uid_ = 0;
 		p->time_ = 0;
+
+		// MIT_uAMPS
+                hdr_rca* rca_hdr = HDR_RCA(p);
+                rca_hdr->meta_size_ = 0;
+
 	} else {
 		p = new Packet;
 		p->bits_ = new unsigned char[hdrlen_];
@@ -818,6 +889,14 @@
 		p->data_ = data_->copy();
 	p->txinfo_.init(&txinfo_);
  
+	// MIT_uAMPS
+        hdr_rca* ch = HDR_RCA(this);
+        hdr_rca* new_ch = HDR_RCA(p);
+        if (ch->meta_size_) {
+		new_ch->meta_size_ = ch->meta_size_;
+		memcpy(new_ch->meta_, ch->meta_, ch->meta_size_+1);
+        }
+
 	return (p);
 }
 
@@ -842,4 +921,12 @@
         }
 }
 
+// MIT_uAMPS
+inline void Packet::PrintRcHeader(Packet *p, char *layer)
+{
+	hdr_cmn *hdr = HDR_CMN(p);
+	hdr_rca *rca_hdr = HDR_RCA(p);
+	printf("%s Layer received: Type=%d data_size=%d\n\tMeta = %s\n\tSource = %x\n\tTarget = %x\n\tLink_target =%x\n",layer,rca_hdr->msg_type(), hdr->size(), rca_hdr->meta(),rca_hdr->rca_mac_src(), rca_hdr->rca_mac_dst(), rca_hdr->rca_link_dst());
+}
+
 #endif

diff -rupN ns-allinone-2.35-orig/ns-2.35/Makefile.in ns-allinone-2.35/ns-2.35/Makefile.in
--- ns-allinone-2.35-orig/ns-2.35/Makefile.in	2009-06-14 19:35:44.000000000 +0200
+++ ns-allinone-2.35/ns-2.35/Makefile.in	2009-11-12 15:43:11.000000000 +0100
@@ -328,6 +328,33 @@ OBJ_CC = \
 	wpan/p802_15_4sscs.o wpan/p802_15_4timer.o \
 	wpan/p802_15_4trace.o wpan/p802_15_4transac.o \
 	apps/pbc.o \
+    mannasim/accessPointApp.o \
+    mannasim/aggregateProcessing.o \
+    mannasim/battery.o \
+    mannasim/carbonMonoxideAppData.o \
+    mannasim/carbonMonoxideDataGenerator.o\
+    mannasim/clusterHeadApp.o \
+    mannasim/commonNodeApp.o \
+    mannasim/dataGenerator.o \
+    mannasim/onDemandData.o \
+    mannasim/onDemandParameter.o \
+    mannasim/processing.o \
+    mannasim/sensedData.o  \
+    mannasim/sensorBaseApp.o \
+    mannasim/sensorNode.o \
+    mannasim/temperatureAppData.o \
+    mannasim/temperatureDataGenerator.o\
+    mannasim/diffusion/nrAttributes.o\
+    mannasim/diffusion/commonNodeDiffApp.o \
+    mannasim/diffusion/accessPointDiffApp.o \
+    mannasim/leach/mac/leach-wireless-phy.o \
+    mannasim/leach/mac/mac-sensor.o \
+    mannasim/leach/mac/mac-sensor-timers.o \
+    mannasim/leach/rca/rca-ll.o \
+    mannasim/leach/rca/rcagent.o \
+    mannasim/leach/app/leachApp.o \
+    mannasim/leach/leachAgent.o \
+    mannasim/leach/app/accessPointLeachApp.o \
 	@V_STLOBJ@
 
 
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/accessPointApp.cc ns-allinone-2.35/ns-2.35/mannasim/accessPointApp.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/accessPointApp.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/accessPointApp.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,238 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Implementation of the application that makes the comunication between inside 
+/// the WSN and outside it: the access point (AP). The AP is called "Sink" when 
+/// we are dealing with a flat WSN, and "Base Station" when it comes to a 
+/// hierachical WSN.
+///
+/// authors: Linnyer B. Ruiz
+///	         Fabr�cio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#include "accessPointApp.h"
+
+/// This static class Provides an instance of the AccessPoint class in 
+/// the TCL simulation script.
+static class AccessPointClass : public TclClass
+{
+	public:
+		AccessPointClass() : TclClass("Application/AccessPointApp"){}
+		TclObject* create(int, const char*const*){
+			return (new AccessPointApp);
+		}
+}class_access_point_app;
+
+/// AccessPoint constructor. Binds TCL script parameters to C++ code variables.
+AccessPointApp::AccessPointApp():Application()
+{
+	bind("destination_id_",&destination_id);
+	bind("request_type_",&request_type);
+	bind("node_id_",&node_id);
+	
+	//diretorio de saida de acordo com cenario simulado
+	bind("diretorio",&diretorio);
+	
+	/// Default value for request type (REAL)
+	request_type = 0;
+	onDemandData_ = NULL;
+} 
+
+/// 
+/// NOTE: Specialization of process_data from the NS-2 Process::process_data 
+/// function. This method is invoked in Agent::recv().
+void AccessPointApp::process_data(int size, AppData* data)
+{
+  /// Modified by Fabricio Silva. Prevents broadcast messages 
+  /// to be erroneous received.
+  if(data->type() == ON_DEMAND_DATA)
+  {
+    return;
+  }
+
+
+
+  AppDataList list = ((SensedData*)data)->getData();
+  printf("Access point - Received a message with %d elements\n",
+         (int)list.size());  
+
+  for(AppDataList::iterator it = list.begin(); it != list.end(); it++)
+  {
+    printf("Message received from node %d with %lf delay ::: %lf %lf\n", 
+    	((SensedData *) data)->node_id(),
+    	Scheduler::instance().clock() - ((SensedData *) data)->timeStamp(),
+    	((SensedData *) data)->timeStamp(), 
+    	Scheduler::instance().clock());
+  }
+//  forward_data(size, data);
+}
+
+/// 
+void AccessPointApp::forward_data(int size, AppData* data){
+
+  AppDataList list = ((SensedData*)data)->getData();
+  //AppDataList::iterator it;
+  //for(it = list.begin(); it != list.end(); it++){
+  //  TemperatureAppData* d = (TemperatureAppData*)(*it);
+  //  //printf("AccessPointApp::forward_data: %f\n",d->data());
+  //}
+
+  agent_->daddr() = destination_id;
+  agent_->dport() = DEFAULT_PORT_;
+  agent_->sendmsg(AP_MSG_BYTES_, data->copy());
+
+}
+
+/// Send on demand message.
+void AccessPointApp::send_request()
+{
+	printf("<<Access Point sending a request message.>>\n");
+	if(onDemandData_ == NULL)
+	{
+		fprintf(stderr,"AccessPointApp::send_request - no parameter defined yet.");
+		return;
+	}
+	
+	//temporario este TRAP e SENSOR_REPORT
+	onDemandData_->msgType() = TRAP_;
+	onDemandData_->eventType() = SENSOR_REPORT_;
+	onDemandData_->node_id() = node_id;
+	
+	agent_->daddr() = IP_BROADCAST;
+	agent_->dport() = DEFAULT_PORT_;
+	agent_->sendmsg(AP_MSG_BYTES_,onDemandData_->copy());
+	onDemandData_ = NULL;
+}
+
+int AccessPointApp::command(int argc, const char*const* argv)
+{
+	if(argc == 2)
+	{
+		if(strcmp("send_request",argv[1]) == 0)
+		{
+			send_request();
+			return TCL_OK;
+		}
+		else
+		{
+			if(strcmp("stop",argv[1]) == 0)
+			{
+				stop();
+				return TCL_OK;
+			}
+		}
+	}
+      
+
+  /**
+   * Syntax form:
+   * 
+   * access_point "add_temp_data_param 25.0 0" OU
+   *
+   * access_point "add_temp_data_param 25.0" --> uses the default (0)
+   *
+   * Creates a OnDemandParameter of temperature that are greater (0) than 25.0
+   *
+   * For each SensedData (temperature,...)
+   *
+   */
+	if(argc == 3)
+	{
+		if(strcmp("add_temp_data_param",argv[1]) == 0)
+		{
+			create_parameter(new  TemperatureAppData(atof(argv[2]),
+                                                    (double)(Scheduler::instance().clock())),
+                             0);
+			return TCL_OK;
+		}
+		else
+		{
+			if(strcmp("add_carbon_data_param",argv[1]) == 0)
+			{
+				create_parameter(new CarbonMonoxideAppData(atof(argv[2]),
+                                                           (double)(Scheduler::instance().clock())),
+                                 0);
+				return TCL_OK;
+			}
+		}
+	}
+	
+	if(argc == 4)
+	{
+		if(strcmp("add_temp_data_param",argv[1]) == 0)
+		{
+			create_parameter(new TemperatureAppData(atof(argv[2]),
+                                                   (double)(Scheduler::instance().clock())), 
+                             atoi(argv[3]));
+			return TCL_OK;
+		}
+		else
+		{
+			if(strcmp("add_carbon_data_param",argv[1]) == 0)
+			{
+				create_parameter(new CarbonMonoxideAppData(atof(argv[2]),
+                                                          (double)(Scheduler::instance().clock())), 
+                                 atoi(argv[3]));
+				return TCL_OK;
+			}
+		}
+	}
+	return Application::command(argc,argv);
+}
+
+/// 
+void AccessPointApp::create_parameter(AppData* data, int operation)
+{
+	if(onDemandData_ == NULL)
+	{
+		onDemandData_ = new OnDemandData(request_type);
+	}
+	onDemandData_->insertNewData(new OnDemandParameter(data, operation));
+}
+
+void AccessPointApp::stop()
+{
+  /*char diretorio_saida[60];
+
+  switch(diretorio)
+  {
+    case 0:
+      sprintf(diretorio_saida,"data/grid");
+      break;
+    case 1:
+      sprintf(diretorio_saida, "data/aleatorio");
+      break;
+    case 2:
+      sprintf(diretorio_saida, "data/cluster_grid");
+      break;
+    default:
+      printf("erro no diretorio\n");
+      exit(0);
+  }
+
+  Contabiliza::instance()->imprime(diretorio_saida);*/
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/accessPointApp.h ns-allinone-2.35/ns-2.35/mannasim/accessPointApp.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/accessPointApp.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/accessPointApp.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,103 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Implementation of the application that makes the comunication between inside 
+/// the WSN and outside it: the access point (AP). The AP is called "Sink" when 
+/// we are dealing with a flat WSN, and "Base Station" when it comes to a 
+/// hierachical WSN.
+///
+/// authors: Linnyer B. Ruiz
+///	         Fabr�cio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#ifndef __access_point_h__
+#define __access_point_h__
+
+#include <common/agent.h>
+#include <common/packet.h>
+#include <common/ns-process.h>
+
+
+#include "processing.h"
+#include "sensedData.h"
+#include "onDemandData.h"
+#include "sensorBaseApp.h"
+#include "util/accounts.h"
+#include "onDemandParameter.h"
+#include "temperatureAppData.h"
+#include "carbonMonoxideAppData.h"
+
+/// Access point size messages.
+#define AP_MSG_BYTES_ 64
+
+/// Access point application. Simulates the behavior of an access point.
+class AccessPointApp : public Application{
+
+	public:
+	
+		/// Default Constructor
+		AccessPointApp();
+	
+		/// Method called from the transport protocol for the application to 
+		/// receive a message. Method from Process (ns-process.cc) overcharged
+		virtual void process_data(int size, AppData* data);
+
+		/// NS-2 function.
+		int command(int argc, const char*const* argv);
+		
+		/// 
+		virtual void stop();
+
+	protected:
+	
+		/// 
+		virtual void forward_data(int size, AppData* data);	
+
+	private:
+
+		/// Access point address.
+		int node_id;
+
+		/// Message node destination
+		int destination_id;
+	
+		/// Object that represents the response of a request.
+		OnDemandData* onDemandData_;
+	
+		/// Indicates the request type in on demand message (OnDemandData)
+		int request_type;
+		
+		/// Variable used to indicates the directory indicates simulation 
+		/// results directory. Temporary, used on wgrs04.
+		int diretorio;
+
+		void send_request();
+
+		void create_parameter(AppData* data, int operation);
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/aggregateProcessing.cc ns-allinone-2.35/ns-2.35/mannasim/aggregateProcessing.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/aggregateProcessing.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/aggregateProcessing.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,99 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Class that simulates the aggregating processing activity on sensed data. 
+/// It's a specialization of processing class. 
+/// 
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#include "aggregateProcessing.h"
+
+/// This static class creates a link between the C++ class and the TCL script 
+/// in the simulation scenario. Provides an instance of the 
+/// AggregateProcessing class in the TCL simulation script. 
+static class AggregateProcessingClass : public TclClass
+{
+	public:
+		AggregateProcessingClass() : TclClass("Processing/AggregateProcessing"){}
+		TclObject* create(int, const char*const*){
+			return (new AggregateProcessing);
+		}
+
+}class_aggregate_processing;
+
+/// Default construtor, clear processed data buffer (info_)
+AggregateProcessing::AggregateProcessing() : Processing()
+{
+	info_ = NULL;
+}
+
+/// Simulates sensed data aggregating processing. The parametric data
+/// is added in processed data buffer and energy is decresed from node 
+/// battery.
+void AggregateProcessing::processSensedData(AppData* data_)
+{
+	if (info_ == NULL)
+	{
+		info_ = new SensedData;
+	}
+		
+	info_->insertNewData(data_->copy());
+
+	// The activity above wastes sensor node energy! PROCESSING WASTE HERE!
+	((Battery*)sensor_node_->energy_model())->DecrProcessingEnergy(
+												AGGREGATION_INSTRUCTIONS,
+												sensor_node_->instructionsPerSecond(),
+												sensor_node_->processingPower());
+}
+
+/// Receives data from multiple sources and aggregates them. Useful
+/// for cluster head based networks.
+void AggregateProcessing::recvData(AppData* data_)
+{
+	if (info_ == NULL)
+	{
+		info_ = new SensedData;
+	}
+	
+	AppDataList list = ((SensedData*)data_)->getData();
+	AppDataList::iterator it;
+
+	/// Aggregates all sensed data
+	for (it = list.begin(); it != list.end(); it++)
+	{
+		info_->insertNewData(*it);
+	}
+
+	// The activity above wastes sensor node energy! PROCESSING WASTE HERE!
+	((Battery*)sensor_node_->energy_model())->DecrProcessingEnergy(
+												AGGREGATION_INSTRUCTIONS,
+												sensor_node_->instructionsPerSecond(),
+												sensor_node_->processingPower());
+}
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/aggregateProcessing.h ns-allinone-2.35/ns-2.35/mannasim/aggregateProcessing.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/aggregateProcessing.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/aggregateProcessing.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,59 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Class that simulates the aggregating processing activity on sensed data. 
+/// It's a specialization of processing class. 
+/// 
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#ifndef __aggregate_processing__
+#define __aggregate_processing__
+
+#include "processing.h"
+
+/// Specialize Processing class adding aggregation to processing module.
+///
+/// extends Processing
+class AggregateProcessing : public Processing
+{
+	public:
+	
+		/// Constructor
+		AggregateProcessing();
+		
+		/// Simulates sensed data processing. Used in continous and
+		/// programmed data sensing.
+		virtual void processSensedData(AppData* data_);
+		
+		/// Receives data from multiple source and aggregates them.
+		virtual void recvData(AppData* data_);
+};
+
+#endif
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/battery.cc ns-allinone-2.35/ns-2.35/mannasim/battery.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/battery.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/battery.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,145 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// This class represents the power supply of the node. It is derived from
+/// NS-2 Energy model.
+/// 
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#include "battery.h"
+
+/// This static class creates a link between the C++ class and the TCL script 
+/// in the simulation scenario. Provides an instance of the 
+/// Battery class in the TCL simulation script. 
+static class BatteryClass : public TclClass
+{
+	public:
+		BatteryClass ():TclClass ("EnergyModel/Battery") {}
+		TclObject *create (int argc, const char *const *argv){
+			if (argc == 8)
+			{
+				MobileNode *n=(MobileNode*)TclObject::lookup(argv[4]);
+				return (new Battery(n, 
+									atof(argv[5]), 
+									atof(argv[6]), 
+									atof(argv[7])));
+			}
+			else
+			{
+				Tcl::instance().add_error("Wrong arguments to Battery");
+				return 0;
+			}
+        }
+} class_battery;
+
+/// Constructor. Invoke EnergyModel constructor with need parameters.
+Battery::Battery(MobileNode* node, double energy, double l1, double l2) : 
+										EnergyModel(node, energy, l1, l2)
+{
+}
+
+/// Computes the energy consumed when the node is sensing data. 
+void Battery::DecrSensingEnergy(double sensing_time, double sensing_power)
+{
+	double consumed_energy = sensing_power * sensing_time;
+	
+	/// The energy_ variable indicates the amount of energy of the node. 
+	/// This variable is defined at EnergyModel class. 
+	if (energy_ <= consumed_energy)
+	{
+		energy_ = 0.0;
+	}
+	else
+	{
+		energy_ = energy_ - consumed_energy;
+	}
+}
+
+/// Computes the energy consumed when the node is processing data. 
+void Battery::DecrProcessingEnergy(int number_instructions, double instructions_per_second, double processing_power)
+{
+	double processing_time;
+	double consumed_energy;
+	
+	if (instructions_per_second == 0)
+	{
+		fprintf(stderr,"Battery::DecrProcessingEnergy - Division by zero!!!\n");
+		abort();
+	} 
+ 	
+ 	processing_time = ((double)(number_instructions))/instructions_per_second;
+	consumed_energy = processing_power * processing_time;
+	
+	/// The energy_ variable indicates the amount of energy of the node. 
+	/// This variable is defined at EnergyModel class. 
+	if (energy_ <= consumed_energy)
+	{
+		energy_ = 0.0;
+	}
+	else
+	{
+		energy_ = energy_ - consumed_energy;
+	}
+}
+
+/// Turn senso node On.
+void Battery::setNodeOn(){
+	node_on_ = true;
+}
+
+/// Turn the node Off
+void Battery::setNodeOff(){
+	node_on_ = false;
+}
+
+/// Put node in sleep mode.
+void Battery::sleep()
+{
+	struct if_head head;
+
+	head = ((Node *) node_)->ifhead();
+
+	for (Phy * wp = head.lh_first; wp; wp = wp->nextnode())
+	{
+		((WirelessPhy *) wp)->node_off();
+	}	
+}
+
+/// Wake up sleppy sensor node.
+void Battery::wakeUp()
+{
+	struct if_head head;
+
+	head = ((Node *) node_)->ifhead();
+
+	for (Phy * wp = head.lh_first; wp; wp = wp->nextnode())
+	{
+		((WirelessPhy *) wp)->node_on();
+	}
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/battery.h ns-allinone-2.35/ns-2.35/mannasim/battery.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/battery.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/battery.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,82 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// This class represents the power supply of the node. It is derived from
+/// NS-2 Energy model.
+/// 
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#ifndef __ns_battery_h__
+#define __ns_battery_h__
+
+#include <node.h>
+#include <energy-model.h>
+#include <wireless-phy.h>
+
+/* This class represents the sensor node battery. It inherits from
+the NS-2 EnergyModel*/
+
+/// Represents sensor node batery. Include method to turn the node on and off
+/// put it to sleep and make it wake up. Also contains a method to decrease 
+/// energy when work is done by the sensor.
+///
+/// extends EnergyModel
+class Battery : public EnergyModel{
+
+  public:
+    
+    /* Construtor: invoke the EnergyModel constructor with the need parameters */
+    /// Constructor
+    Battery(MobileNode* node, double energy, double l1, double l2);
+
+    /* fun��o que decrementa a energia gasta com sensoriamento:
+     * par�metros: tempo de sensoriamento e pot�ncia (W) do sensor
+     * */
+    virtual void DecrSensingEnergy(double sensing_time, double sensing_power);
+
+    /* fun��o que decrementa a energia gasta com processamento 
+     * par�metros: n�mero de instru��es realizadas e pot�ncia (W) 
+		 * do processador
+     * */
+    virtual void DecrProcessingEnergy(int number_instructions, double instructions_per_second, double processing_power);
+
+	/// Turn node On.
+    virtual void setNodeOn();
+    
+	/// Turn node Off.
+    virtual void setNodeOff();
+
+	/// Put node in Sleep mode.
+    virtual void sleep();
+    
+    /// Wake up the sleepy node.
+    virtual void wakeUp();
+};
+
+#endif 
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/carbonMonoxideAppData.cc ns-allinone-2.35/ns-2.35/mannasim/carbonMonoxideAppData.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/carbonMonoxideAppData.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/carbonMonoxideAppData.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,136 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Defines a carbon monoxide application data type. Encapsulates the 
+/// raw carbon monoxide data from DataGenerator.
+/// 
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+/// 		 Julio Cesar e Melo
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#include "carbonMonoxideAppData.h"
+
+/// CarbonMonoxideAppData constructor. Sets carbonMonoxideLevel and colleted 
+/// time for the object, also calls super class constructor AppDataAttrsExporter() 
+/// with AppDataType carbon monoxide.
+CarbonMonoxideAppData::CarbonMonoxideAppData(double carbonMonoxideLevel, double sample_time) 
+                       : AppDataAttrsExporter(CARBON_MONOXIDE_SENSED_DATA)
+{
+	data_ = carbonMonoxideLevel;
+	time_ = sample_time;
+}
+
+/// Checks if the value of the current object of this class is greater 
+/// than the value of the parameter object. Until now, we only implemented
+/// the GREATER THAN  option for EVENT DRIVEN network.
+bool CarbonMonoxideAppData::checkEvent(AppData* data_)
+{
+	/// Already know that AppData dynamic type is CarbonMonoxideAppData, 
+	/// so perform the casting.
+	double value = ((CarbonMonoxideAppData*)data_)->data();
+	
+	if(value >= this->data())
+	{
+		return true;
+	}
+	else
+	{
+		return false;
+	}
+} 
+
+/// Check if current value satisfies the condition especified by operation 
+/// and data parameters. This method is used in ON DEMAND network.
+bool CarbonMonoxideAppData::compareData(AppData* data, int operation)
+{
+	/// Already know that AppData dynamic type is CarbonMonoxideAppData, 
+	/// so perform the casting.
+	double value = ((CarbonMonoxideAppData*)data)->data();
+	
+	switch (operation)
+	{
+		case GREATER_THAN:
+			return (value > this->data());
+			
+		case LESS_THAN:
+			return (value < this->data());
+		
+		case EQUAL:
+			return (value == this->data());
+		
+		default:
+			fprintf(stderr,"CarbonMonoxideAppData::compareData - Invalid Operation.\n");
+			return false;
+	}
+}
+
+/// Sets atributes about carbon monoxide sensed data. Called by 
+/// CommonNodeDiffApp (directed difusion).
+/// 
+/// Created by Julio Cesar e Melo
+void CarbonMonoxideAppData::setAttributes(NRAttrVec * attrs)
+{
+	attrs->push_back(
+		SensedValueAttr.make(NRAttribute::IS, this->data()));
+}
+
+/// Returns the size of the CarbonMonoxideAppData object. Size in bytes.
+int CarbonMonoxideAppData::size() const
+{
+	return sizeof(CarbonMonoxideAppData);
+}
+
+/// Creates a copy of this CarbonMonoxideAppData object.
+AppData * CarbonMonoxideAppData::copy()
+{
+	return new CarbonMonoxideAppData(data_, time_);
+}
+
+/// Returns carbon monoxide data.
+double CarbonMonoxideAppData::data()
+{
+	return data_;
+}
+
+/// Ajusts carbon monoxide data.
+void CarbonMonoxideAppData::setData(double data)
+{
+	data_ = data;
+}
+
+/// Returns carbon monoxide timestamp
+double CarbonMonoxideAppData::time()
+{
+	return time_;
+}
+
+/// Ajusts carbon monoxide data timestamp.
+void CarbonMonoxideAppData::setTime(double time)
+{
+	time_ = time;
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/carbonMonoxideAppData.h ns-allinone-2.35/ns-2.35/mannasim/carbonMonoxideAppData.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/carbonMonoxideAppData.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/carbonMonoxideAppData.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,93 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Defines a carbon monoxide application data type. Encapsulates the 
+/// raw carbon monoxide data from DataGenerator.
+/// 
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+/// 		 Julio Cesar e Melo
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#ifndef __carbonMonoxideAppData_h__
+#define __carbonMonoxideAppData_h__
+
+#include <common/ns-process.h>
+#include <nr.hh>
+
+#include "onDemandParameter.h"
+#include "diffusion/nrAttributes.h"
+#include "diffusion/attrsExporter.h"
+
+/// Creates a carbon monoxide  application data type. This data type 
+/// represents the pure data collect by the sensor node. This data
+/// is sent to the processing module for futher treatment.
+///
+/// extends AppDataAttrsExporter
+class CarbonMonoxideAppData : public AppDataAttrsExporter
+{
+	public:
+	
+		/// Constructor, parameters are carbon monoxide data collected
+		/// and timestamp
+		CarbonMonoxideAppData(double carbonMonoxideLevel, double sample_time); 
+		
+		/// Creates a copy of the object.
+		AppData* copy();
+		
+		/// Size, in bytes, of the object.
+		int size() const;
+			
+		/// Check if satisfies the condition especified by
+		/// operation and value. It is used in ON DEMAND network
+		bool compareData(AppData* data, int operation);
+		
+		/// Check if the value is greater than this one.
+		/// It is used in EVENT DRIVEN network
+        bool checkEvent(AppData* data_);
+        
+        /// Accessor methods
+        double data();
+		double time();
+		
+		void setData(double data);
+		void setTime(double time);
+	
+ 		/// Set attributes of sensed data. This is called by CommonNodeDiffApp.
+		/// Changed by Julio Cesar e Melo.
+		virtual void setAttributes(NRAttrVec * attrs);
+    
+	private:
+	
+		/// Carbon monoxide data.
+		double data_;
+		
+		/// Timestamp for monoxide data. 
+		double time_;
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/carbonMonoxideDataGenerator.cc ns-allinone-2.35/ns-2.35/mannasim/carbonMonoxideDataGenerator.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/carbonMonoxideDataGenerator.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/carbonMonoxideDataGenerator.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,108 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// 
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+///
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Generates synthetic temperature data. Simulates a carbon monoxide sensor 
+/// node sensing the environment.
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+/// 
+#include "carbonMonoxideDataGenerator.h"
+
+
+/// This static class creates a link between the C++ class and the TCL script 
+/// in the simulation scenario. Provides an instance of  
+/// CarbonMonoxideDataGenerator class in the TCL simulation script. 
+static class CarbonMonoxideDataGeneratorClass : public TclClass
+{
+	public:
+		CarbonMonoxideDataGeneratorClass() : TclClass(
+				"DataGenerator/CarbonMonoxideDataGenerator"){}
+		TclObject* create(int, const char*const*)
+		{
+			return (new CarbonMonoxideDataGenerator);
+		}
+
+}class_carbon_monoxide_data_generator;
+
+/// Constructor, binds TCL script parameters to C++ code variables and
+/// creates a disseminating timer.
+CarbonMonoxideDataGenerator::CarbonMonoxideDataGenerator() : 
+								DataGenerator(CARBON_MONOXIDE_SENSED_DATA)
+{
+	// Creates the random number that that generates the syntectic data.
+	rand_ = new RNG(RNG::HEURISTIC_SEED_SOURCE, 1);
+	
+	/// Get from the TCL script: data average, standard deviation, and maximum
+	/// Carbon Monoxide value allowed.
+	bind("avg_measure",&avg_measure);
+	bind("std_deviation",&std_deviation);
+	bind("maximumCarbonMonoxideValue",&maximumCarbonMonoxideValue);
+}
+
+/// Carbon monoxide sensing simulation. This is the most important function 
+/// since it creates the random data, encapsulates it on a AppData type and 
+/// return it to the sensor node.
+AppData* CarbonMonoxideDataGenerator::collect()
+{
+	double monoxide = rand_->normal(avg_measure, std_deviation);
+
+	printf("Carbon Monoxide Data %f - Time %f\n",
+										monoxide,Scheduler::instance().clock());
+	
+	CarbonMonoxideAppData* data = new CarbonMonoxideAppData(
+										monoxide, Scheduler::instance().clock());
+	
+	/// Returns an application data that contains the carbon monoxide collect 
+	/// value
+	return data;
+}
+
+/// NS-2 command function overloaded. Deals with TCL script commands to C++ 
+/// implementation.
+int CarbonMonoxideDataGenerator::command(int argc, const char*const* argv)
+{
+	if(argc == 3){
+		if(strcmp("set-event",argv[1]) == 0)
+		{
+			avg_measure = atof(argv[2]);
+			printf("EVENT: New avg_measure: %.3f\n",atof(argv[2]));
+			return TCL_OK;
+		}
+	}
+	return DataGenerator::command(argc, argv);
+}
+
+/// Returns average measure for synthetic carbon monoxide generation.
+double CarbonMonoxideDataGenerator::getAvgMeasure()
+{
+	return avg_measure;
+}
+
+/// Sets average measure value for synthetic carbon monoxide generation.
+void CarbonMonoxideDataGenerator::setAvgMeasure(double avg_measure)
+{
+	this->avg_measure = avg_measure;
+}
+
+/// Returns the maximum allowed carbon monoxide value.
+CarbonMonoxideAppData* CarbonMonoxideDataGenerator::getMaximumAllowedValue()
+{
+	return new CarbonMonoxideAppData(maximumCarbonMonoxideValue,0.0);
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/carbonMonoxideDataGenerator.h ns-allinone-2.35/ns-2.35/mannasim/carbonMonoxideDataGenerator.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/carbonMonoxideDataGenerator.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/carbonMonoxideDataGenerator.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,62 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// 
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+///
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Generates synthetic carbon monoxide data. Simulates a temperature sensor 
+/// node sensing the environment.
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+/// 
+#ifndef __carbon_monoxide_data_generator__
+#define __carbon_monoxide_data_generator__
+
+#include "dataGenerator.h"
+#include "carbonMonoxideAppData.h"
+
+/// Generate synthetic carbon monoxide data. Synthetic data is based on average 
+/// and standard deviation values for a normal probability distribution. A 
+/// maximum allowed value should also be set.
+/// extends DataGenerator
+class CarbonMonoxideDataGenerator : public DataGenerator
+{
+	public:
+		
+		/// Constructor
+		CarbonMonoxideDataGenerator();
+		
+		/// Data sensing simulation function
+		AppData* collect();
+		
+		/// NS-2 function
+		virtual int command(int argc, const char*const* argv);
+		
+		/// Accessor methods
+		double getAvgMeasure();
+		void setAvgMeasure(double avg_measure);
+		virtual CarbonMonoxideAppData* getMaximumAllowedValue();
+		
+	protected:
+		RNG* rand_;
+		
+		double avg_measure;
+		double std_deviation;
+		double maximumCarbonMonoxideValue;
+};
+
+#endif 
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/clusterHeadApp.cc ns-allinone-2.35/ns-2.35/mannasim/clusterHeadApp.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/clusterHeadApp.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/clusterHeadApp.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,201 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// This class simulates the behavior of a cluster head in a wireless
+/// sensor network. Dispates its more capacity to process and disseminate
+/// sensed data, a cluster head must also have a group of nodes under
+/// its responsability - a child list.
+///
+/// authors: Linnyer B. Ruiz
+///	         Fabr�cio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#include "clusterHeadApp.h"
+
+/// This static class Provides an instance of the ClusterHeadApp class in 
+/// the TCL simulation script.
+static class ClusterHeadAppClass : public TclClass{
+
+	public:
+		ClusterHeadAppClass() :	TclClass("Application/SensorBaseApp/ClusterHeadApp"){}
+		TclObject* create(int, const char*const*){
+				return (new ClusterHeadApp);
+		}
+
+}class_cluster_head_app;
+
+/// Default constructor. Does notjhing, only calls the super class
+/// (SensorBaseApp) default constructor.
+ClusterHeadApp::ClusterHeadApp() : SensorBaseApp()
+{
+}
+
+/// ClusterHeadApp object needs this method to receive request (on demand) 
+/// messages. 
+/// NOTE: Specialization of process_data from the NS-2 Process::process_data 
+/// function. This method is invoked in Agent::recv().
+void ClusterHeadApp::process_data(int size, AppData* data){
+		
+	if(data == NULL)
+	{
+		fprintf(stderr,"ClusterHeadApp::process_data() --> data is NULL\n");
+		abort();
+	} 
+	
+	/// The received data isn�t for "me"			
+	if(((SensedData*)data)->node_id() != destination_id_)
+	{
+		/// It is a broadcast message from other Cluster Head
+		if(data->type() == ON_DEMAND_DATA)
+		{
+			return;
+		}
+		
+		/// The node from where the message came isn�t on the
+		/// Cluster Head child list, insert node on child list.
+		if(!search_child(((SensedData*)data)->node_id()))
+		{
+			insert_child(((SensedData*)data)->node_id());
+		}
+
+		if(processing_ == NULL)
+		{
+			fprintf(stderr,"ClusterHeadApp::process_data() --> processing is NULL\n");
+			abort();
+		}	
+		
+		/// Here occurs the data processing
+		processing_->recvData(data);
+		
+		/// If the disseminating type is continuous, send data 
+		/// immediately
+		if(disseminating_type_ == CONTINUOUS)
+		{
+			disseminateData();
+		}
+		
+	}
+	else
+	{
+		/// The received data is for "me" and I am an Access Point
+		//is the AP
+		//implementar para recebimento de request
+		if(data->type() == ON_DEMAND_DATA)
+		{
+			//ver como passar este m�todo para o processing, j� que ser� 
+			//diferente do nodo comum
+			processRequest(data);
+		}
+	}
+	printf("Cluster Head Node %d - Received message - Time %.3f - Source Node %d!\n",
+			sensor_node_->nodeid(), Scheduler::instance().clock(),((SensedData*)data)->node_id());
+}
+
+/// Disseminate the sensed data throught the network. 
+void ClusterHeadApp::disseminateData()
+{
+	if(processing_ == NULL)
+	{
+		fprintf(stderr,"ClusterHeadApp::disseminateData() --> processing is NULL\n");
+		abort();
+	}
+
+	/// Get the processed data.
+	SensedData* data_ = processing_->getProcessedData();
+
+	/// If there is any information to be disseminated, do it!
+	if(data_ != NULL)
+	{
+		printf("Cluster Head Node %d - Disseminating Data - Destination Node %d - Time %.3f\n",
+						sensor_node_->nodeid(), destination_id_,Scheduler::instance().clock());
+
+		/// Configure agent to disseminate the parameter data.
+		agent_->daddr() = destination_id_;
+		agent_->dport() = DEFAULT_PORT_;
+
+		/// verificar como � a mensagem sem gerenciamento, pois TRAP � de 
+		/// gerenciamento.
+		data_->msgType() = TRAP_;
+		data_->eventType() = SENSOR_REPORT_;
+		data_->node_id() = sensor_node_->nodeid();
+
+		/// Send the message.
+		agent_->sendmsg(CH_MSG_BYTES_,data_->copy());
+		processing_->resetData();
+	}
+}
+
+/// Forwards a request message for all child in child list.
+void ClusterHeadApp::processRequest(AppData* data)
+{
+	if(data == NULL)
+	{
+		fprintf(stderr,"ClusterHeadApp::processRequest() --> data is NULL\n");
+		abort();
+	}	
+
+	printf("Cluster Head Node %d sending request data!\n",sensor_node_->nodeid());	
+
+	/// Configure agent to disseminate the parameter data.
+	agent_->daddr() = IP_BROADCAST;
+	agent_->dport() = DEFAULT_PORT_;
+	
+	/// Changes the address of source node so the child will receive the 
+	/// message.
+	((SensedData*)data)->node_id() = sensor_node_->nodeid();
+
+	/// Send the message.
+	agent_->sendmsg(CH_MSG_BYTES_,data->copy());
+}
+
+/// Inserts a nwe item in Cluster Head child list
+void ClusterHeadApp::insert_child(int id)
+{
+	child_list.push_back(id);
+}
+
+/// Removes all itens that are equal to id. 
+void ClusterHeadApp::remove_child(int id)
+{
+  child_list.remove(id);
+}
+
+/// Returns a boolean indicating if node "id" is in cluster head
+/// child list.
+bool ClusterHeadApp::search_child(int id)
+{
+	for(IdList::iterator it = child_list.begin(); it != child_list.end(); ++it)
+	{
+		if(*it == id)
+		{
+			return true;
+		}
+	}
+	return false;
+}
+
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/clusterHeadApp.h ns-allinone-2.35/ns-2.35/mannasim/clusterHeadApp.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/clusterHeadApp.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/clusterHeadApp.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,90 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// This class simulates the behavior of a cluster head in a wireless
+/// sensor network. Dispates its more capacity to process and disseminate
+/// sensed data, a cluster head must also have a group of nodes under
+/// its responsability - a child list.
+///
+/// authors: Linnyer B. Ruiz
+///	         Fabr�cio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#ifndef __cluster_head_h__
+#define __cluster_head_h__
+
+#include <list>
+#include <stdio.h>
+#include <common/ns-process.h>
+
+#include "sensorBaseApp.h"
+
+using namespace std;
+
+typedef list<int> IdList;
+
+/// Size of cluster head messages (in bytes)
+#define CH_MSG_BYTES_ 64
+
+/// Simulates the behavior of a wireless sensor network cluster head
+/// device.
+class ClusterHeadApp : public SensorBaseApp {
+
+  public:
+
+	/// Default Constructor
+    ClusterHeadApp();
+
+	/// Process the sensed data. Specialization of 
+	/// Process::process_data() function. See NS-2 documentation
+	/// for details.
+    virtual void process_data(int size, AppData* data);
+
+    virtual void processRequest(AppData* data);
+  
+  protected:
+    
+    /// Insert a new node in the child list.
+    void insert_child(int id);
+  
+    /// Remove the node with addr = id in the child list.
+    void remove_child(int id);
+
+    /// Search for a node with addr = id in the child list.
+    bool search_child(int id); 
+
+    /// Disseminate data to the network.
+    virtual void disseminateData();
+
+  private:
+  
+  	/// Children list of the cluster head
+    IdList child_list;
+  
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/commonNodeApp.cc ns-allinone-2.35/ns-2.35/mannasim/commonNodeApp.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/commonNodeApp.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/commonNodeApp.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,219 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Represents common-nodes application which performs data dissemination
+/// using the disseminateData method, processing using processSensedData 
+/// method and other functions using CommonNodeApp methods. 
+/// The CommonNodeApp is a specialization of SensorBaseApp class.
+/// 
+/// authors: Linnyer B. Ruiz
+///	         Fabr�cio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#include "commonNodeApp.h"
+
+/// This static class Provides an instance of the CommonNodeApp class in 
+/// the TCL simulation script
+static class CommonNodeAppClass : public TclClass
+{
+	public:
+		CommonNodeAppClass() : TclClass("Application/SensorBaseApp/CommonNodeApp"){}
+		TclObject* create(int, const char*const*){
+			return (new CommonNodeApp);
+		}
+
+}class_common_node_app;
+
+/// Default constructor. Does notjhing, only calls the super class
+/// (SensorBaseApp) default constructor.
+CommonNodeApp::CommonNodeApp():SensorBaseApp()
+{
+}
+
+/// NS-2 command function overloaded. Deals with TCL script commands to C++ 
+/// implementation.
+int CommonNodeApp::command(int argc, const char*const* argv)
+{
+	if (argc == 2)
+	{				
+		if (strcmp(argv[1],"start") == 0) {
+			start();
+			return TCL_OK;
+		}
+		if (strcmp(argv[1],"stop") == 0) {
+			stop();
+			return TCL_OK;
+		}
+	}
+	return SensorBaseApp::command(argc, argv);
+}
+
+/// CommonNodeApp object needs this method to receive request (on demand) 
+/// messages. 
+/// NOTE: Specialization of process_data from the NS-2 Process::process_data 
+/// function. This method is invoked in Agent::recv().
+void CommonNodeApp::process_data(int size, AppData* data)
+{	
+	if (isDead())
+	{
+		return;
+	}
+
+	if(data == NULL)
+	{
+		fprintf(stderr,"CommonNodeApp::process_data() --> data is NULL\n");
+		abort();
+	}	
+	
+	/// If the message is for "me", process it (throught disseminanteDaTa()).
+	if(((SensedData*)data)->node_id() == destination_id_)
+	{
+		printf("Common Node %d receive a message.\n",sensor_node_->nodeid());
+		disseminateData(((SensedData*)processing_->processRequest(data))); 
+	}
+	else
+	{
+//		fprintf(stderr,"Source is not correct!!\n");	
+	}
+}
+
+/// Disseminate the sensed data throught the network. 
+void CommonNodeApp::disseminateData()
+{
+	if (isDead())
+	{
+		return;
+	}
+
+	if(processing_ == NULL)
+	{
+		fprintf(stderr,"CommonNodeApp::disseminateData() --> processing is NULL\n");
+		abort();
+	}
+
+	// If there is information to be disseminated, do it!
+	SensedData* data_ = processing_->getProcessedData();
+	if (data_ != NULL){
+		disseminateData(data_);
+	    processing_->resetData();
+	}	
+}
+
+/// Disseminate the sensed data throught the network. The data to be sent is
+/// passed by reference. This function is also invoked by the it�s no parametric
+/// version - disseminateData().
+void CommonNodeApp::disseminateData(SensedData* data_)
+{  
+	if(data_ != NULL && !isDead())
+	{
+		/// For user information only.
+		printf("Common Node %d - Disseminating data -  Time %.3f - Destination node %d\n",
+				sensor_node_->nodeid(),Scheduler::instance().clock(),destination_id_);
+
+		/// Configure agent to disseminate the parameter data.
+		agent_->daddr() = destination_id_;
+		agent_->dport() = DEFAULT_PORT_;
+		
+		/// verificar como � a mensagem sem gerenciamento, pois TRAP � de 
+		/// gerenciamento.
+	   	data_->msgType() = TRAP_;
+     	data_->eventType() = SENSOR_REPORT_;
+	   	data_->node_id() = sensor_node_->nodeid();
+	   	
+	   	/// Send the message.
+     	agent_->sendmsg(MSG_BYTES_,data_->copy());
+	}
+}
+
+/// Receives data from the sensing activity and performs data 
+/// processing according to the processing object that
+/// is attached to the node (Processing::processSensedData method).
+void CommonNodeApp::recvSensedData(AppData* data_)
+{
+	if (isDead())
+	{
+		return;
+	}
+
+	if(data_ == NULL){
+		fprintf(stderr,"CommonNodeApp::recvSensedData() --> data_ is NULL\n");
+		abort();
+	}
+	
+	if(processing_ == NULL)
+	{
+		fprintf(stderr,"CommonNodeApp::recvSensedData() --> processing is NULL\n");
+		abort();
+	}
+
+	/// Here occurs the data processing
+	processing_->processSensedData(data_->copy());
+
+	/// If the disseminating type is continuous, send data 
+	/// immediately
+	if(disseminating_type_ == CONTINUOUS){
+		disseminateData();
+	}
+}
+
+/// Receives data from the sensing activity and performs data 
+/// processing according to the processing object that
+/// is attached to the node (Processing::processSensedData method).
+/// This function is oriented to a EVENT_DRIVEN sensor network. It
+/// verify if the data is of interest, and disseminate it only if it is.
+void CommonNodeApp::recvSensedData(AppData* data_, AppData* eventData_)
+{
+	if (isDead())
+		return;
+
+	if(processing_ == NULL)
+	{
+		fprintf(stderr,"CommonNodeApp::recvSensedData() --> processing is NULL\n");
+		abort();
+	}	
+
+	AppData* processedData_;
+
+	/// Here occurs the data processing
+	processedData_ = processing_->processSensedData(data_->copy(), 
+													eventData_->copy());
+
+	/// Data is of interest so disseminate it.
+	if(processedData_ != NULL)
+	{
+		SensedData* sensedData = new SensedData();
+		sensedData->insertNewData(processedData_);
+		disseminateData(sensedData);
+	}
+}
+
+/// Returns a boolean indicating if the node is dead or not. Dead means that the
+/// node ran out energy.
+inline bool CommonNodeApp::isDead()
+{
+	return ((Battery *) sensor_node_->energy_model())->energy() <= 0;
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/commonNodeApp.h ns-allinone-2.35/ns-2.35/mannasim/commonNodeApp.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/commonNodeApp.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/commonNodeApp.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,95 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Represents common-nodes application which performs data dissemination
+/// using the disseminateData method, processing using processSensedData 
+/// method and other functions using CommonNodeApp methods. 
+/// The CommonNodeApp is a specialization of SensorBaseApp class.
+/// 
+/// authors: Linnyer B. Ruiz
+///	         Fabr�cio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#ifndef __common_node_app__
+#define __common_node_app__
+
+#include <common/ns-process.h>
+#include <common/agent.h>
+#include <common/packet.h>
+
+#include "battery.h"
+#include "processing.h"
+#include "sensedData.h"
+#include "processing.h"
+#include "sensorNode.h"
+#include "onDemandData.h"
+#include "sensorBaseApp.h"
+#include "dataGenerator.h"
+#include "onDemandParameter.h"
+
+/// Common sensor node application. Sensing Dynamics:
+/// 1. Data is generated by the DataGenerator object.
+/// 2. The Processing object receives the generated data and 
+///    disseminates it acording to the dissemination type to be 
+///	   done (programed, continuous, on demand or event driven). 
+/// extends SensorBaseApp
+class CommonNodeApp : public SensorBaseApp {
+
+	public:
+	
+		/// Constructor
+		CommonNodeApp();
+
+		/// NS-2 Function
+		int command(int argc, const char*const* argv);
+		
+	protected:
+		
+		/// Process the sensed data. Specialization of 
+		/// Process::process_data() function. See NS-2 documentation
+		/// for details.
+		virtual void process_data(int size, AppData* data_);
+		
+		/// Disseminates data to the network.
+		virtual void disseminateData();
+
+		/// Disseminates the parameter data to the network.
+		virtual void disseminateData(SensedData* data_);
+
+		/// Receives sensed data, process it and disseminate (only in 
+		/// contiuous sensing).
+		virtual void recvSensedData(AppData* data_);
+                
+        /// Receives sensed data, event that generated the data, process
+        /// it, and if the event and data are valid, disseminate data.
+        virtual void recvSensedData(AppData* data_, AppData* eventData_);
+	
+		/// Informs if the node ran off energy or not.
+		inline bool isDead();
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/dataGenerator.cc ns-allinone-2.35/ns-2.35/mannasim/dataGenerator.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/dataGenerator.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/dataGenerator.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,183 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Base class for the generation of synthetic data. Specialized sensed data,
+/// such as temperture, magnetic field, video, among others, should extends 
+/// this class and add the necessary modifications. 
+/// 
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+/// 
+#include "dataGenerator.h"
+
+
+/// Whenever the sensing timer expires, the generator generateData()
+/// method should be invoked. The timer should also be rescheduled.
+void SensingTimer::expire(Event*)
+{
+	gen_->generateData();
+}
+
+/// Constructor. Binds TCL script parameters to C++ code variables and
+/// creates a disseminating timer.
+DataGenerator::DataGenerator(AppDataType type) : TclObject()
+{
+	sensTimer_ = new SensingTimer(this);
+	type_ = type;
+	
+	bind("sensing_type_",&sensing_type_);
+	bind("sensing_interval_",&sensing_interval_);
+
+}
+
+/// Invokes the collect() function of the sensing object, and gives the 
+/// result of it as a parameter for the processData() processing Object 
+/// function. This simulates the behavior of a sensor node, when it senses 
+/// the environment and then gives the obtained data to its 
+/// computational part so it can process it.
+void DataGenerator::generateData()
+{
+	double sensT;
+	SensorAppList::iterator it;	
+	SensorBaseApp *app_instance_;
+	
+	for(it = app_.begin(); it != app_.end(); it++)
+	{
+		app_instance_ = (*it);
+      
+      	/// Display node id for debug proposes
+		if((app_instance_->sensor_node_->nodeid()) > 9)
+		{
+			printf("Node %d - ", app_instance_->sensor_node_->nodeid());
+		}
+		else
+		{
+      		printf("Node 0%d - ", app_instance_->sensor_node_->nodeid());
+		}
+		
+		/// Collect sensed data and pass it to the application to processing
+		if(app_instance_->disseminating_type_ == EVENT_DRIVEN)
+		{ 
+			app_instance_->recvSensedData(collect(), getMaximumAllowedValue());
+		}
+		else
+		{
+			app_instance_->recvSensedData(collect());
+		}
+
+		// The activity above wastes sensor node energy! ENERGY WASTE HERE!
+		((Battery*)app_instance_->sensor_node_->energy_model())->
+			DecrSensingEnergy(SENSING_TIME_,app_instance_->sensor_node_->sensingPower());
+	}
+
+	sensT = getExpireTime();
+	if(sensT != -1)
+	{
+		// Reschedule the event according to sensing activity type
+		sensTimer_->resched(sensT);
+	}
+}
+
+/// Inserts interference on sensed data. NOT IMPLEMENTED YET.
+/// It is recommended to specialize the method if it is going to be implemented.
+void DataGenerator::insertInterference()
+{
+	fprintf(stderr,"DataGenerator::insertInterference() not implemented yet\n");
+	abort();
+}
+
+/// Returns timer expire value, taking into account the sensing activity type.
+double DataGenerator::getExpireTime()
+{
+	switch(sensing_type_)
+	{
+		case PROGRAMED:
+			/// If it is a programed sensing activity, use the sensing_interval_, 
+			/// determined by the user, as the expire timer
+			return sensing_interval_;
+		
+		case CONTINUOUS:
+			/// If it is a continuous sensing activity, get the expire timer 
+			/// from a normal distribution (limits between 0 and 1)
+			return CONTINUOUS_TIME;
+		
+		case ON_DEMAND:
+			return -1;
+		
+		case EVENT_DRIVEN:
+			/// If the sensing activity was defined as EVENT_DRIVEN, it should
+         	/// be replaced by the CONTINUOUS one
+			return CONTINUOUS_TIME;
+
+		default: fprintf(stderr,"Unrecognized sensing type!\n");
+			abort();
+	}
+}
+
+/// Shedule the first sensing event if this activity type isn�t the continuous 
+/// one.
+void DataGenerator::start()
+{
+	double sensT;
+	sensT = getExpireTime();
+
+	if(sensT != -1)
+	{
+	   sensTimer_->resched(sensT);
+	}
+}
+
+/// Stop the object timer, dropping all the scheduled events.
+void DataGenerator::stop()
+{
+	if (sensTimer_->status() == TIMER_PENDING)
+	{
+		sensTimer_->cancel();
+	}
+}
+
+/// Insert a new SensorBaseApp to the DataGenerator SensorBaseApp list.
+void DataGenerator::insertNewApp(SensorBaseApp* app)
+{
+	app_.push_back(app);
+}
+
+/// Returns DataGenerator application data type
+AppDataType DataGenerator::type() const
+{
+	return type_;
+}
+
+/// NS-2 command function overloaded. Deals with TCL script commands to C++ 
+/// implementation.
+int DataGenerator::command(int argc, const char*const* argv)
+{
+	return TclObject::command(argc, argv);
+}
+
+/// Sets the sensing interval for programmed sensing.
+void DataGenerator::setSensingInterval(double si)
+{
+	sensing_interval_=si;
+}
+
+/// Returns sensing interval for programmed sensing.
+double DataGenerator::getSensingInterval()
+{
+	return sensing_interval_;
+}
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/dataGenerator.h ns-allinone-2.35/ns-2.35/mannasim/dataGenerator.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/dataGenerator.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/dataGenerator.h	2009-11-12 15:44:39.000000000 +0100
@@ -0,0 +1,136 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Base class for the generation of synthetic data. Specialized sensed data,
+/// such as temperture, magnetic field, video, among others, should extends 
+/// this class and add the necessary modifications. 
+/// 
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+/// 
+#ifndef __data_generator__
+#define __data_generator__
+
+#include <list>
+#include <tools/rng.h>
+#include <common/ns-process.h>
+
+#include "battery.h"
+#include "sensorNode.h"
+#include "sensorBaseApp.h"
+#include "util/accounts.h"
+
+/// Time interval for continous sensing. Continuity is simulated by reschedule 
+/// the timer with a very small time.
+#define CONTINUOUS_TIME 0.01
+
+class DataGenerator;
+class SensorBaseApp;
+
+/// Type definition for a SensorBaseApp STL list.
+typedef list<SensorBaseApp*> SensorAppList;
+
+/// Sensing timer used to collect data.
+class SensingTimer : public TimerHandler
+{
+	public:
+		SensingTimer(DataGenerator* gen) : TimerHandler(), gen_(gen) {}
+		inline virtual void expire(Event*);
+
+	protected:
+		
+		/// DataGenerator used to "create" sensed data.
+		DataGenerator* gen_;
+};
+
+/// Timer that controls the time interval in which an event is valid.
+class EventTimer : public TimerHandler
+{
+	public:
+		EventTimer(DataGenerator* gen) : TimerHandler(), gen_(gen) {}
+		inline virtual void expire(Event*);
+
+	protected:
+	
+		/// DataGenerator used to "create" sensed data.	
+		DataGenerator* gen_;
+};
+
+/// Base class for sensed data creator objects. Specialized data should extends
+/// this class.
+class DataGenerator : public TclObject
+{
+	public:
+		/// Constructors
+	  	DataGenerator(){}
+	  	DataGenerator(AppDataType type);
+
+		/// NS-2 Function
+		virtual int command(int argc, const char*const* argv);
+	
+		/// Control functions for simulation.
+		void start();
+		void stop();
+		
+		void generateData();
+		void insertNewApp(SensorBaseApp* app);	
+		virtual AppData* collect()
+        {
+           printf("DataGenerator::collect() - specialize this function\n");
+        }
+
+		/// Accessor methods
+		AppDataType type() const;
+		double getSensingInterval();
+		void setSensingInterval(double si);
+
+		friend class EventTimer;
+		friend class SensingTimer;
+		
+	protected:
+		
+		/// Indentify the generator according to the AppData
+		AppDataType type_;
+
+		/// List of applications associated with 
+		SensorAppList app_;
+
+		/// Sensing timer.
+		SensingTimer* sensTimer_;
+
+		/// Sensing interval for programmed sensing. For continous sensing use
+		/// CONTINUOUS_TIME constante.
+		double sensing_interval_;
+
+		/// Define the way the sensor device is supposed to generate data.
+		int sensing_type_;
+
+		// Function that returns the timer expire value, taking into account
+		// the sensing activity type
+		double getExpireTime();
+
+		/// Insert erros into generated data. NOT IMPLEMENTED YET
+		virtual void insertInterference();
+
+		virtual AppData* getMaximumAllowedValue()
+        {
+            printf("DataGenerator::getMaximumAllowedValue() - specialize this function\n");
+        }
+        
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/accessPointDiffApp.cc ns-allinone-2.35/ns-2.35/mannasim/diffusion/accessPointDiffApp.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/accessPointDiffApp.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/diffusion/accessPointDiffApp.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,276 @@
+/* accessPointDiffApp.cc
+ * -- J�lio C�sar e Melo <julio.melo@gmail.com>
+ *
+ * Implementation of class AccessPointDiffApp.
+ *
+ * This class is an application for access point, using
+ * directed diffusion.
+ */
+#include "accessPointDiffApp.h"
+
+static class AccessPointDiffAppClass : public TclClass
+{
+	public:
+		AccessPointDiffAppClass() : TclClass("Application/AccessPointDiffApp") {}
+
+	TclObject * create(int, const char * const *)
+	{
+		return new AccessPointDiffApp();
+	}
+} access_point_diff_app;
+
+
+// Constructor
+AccessPointDiffApp::AccessPointDiffApp()
+{
+//	callback_ = new MessageReceiver(this);
+}
+
+// Tcl command interpreter
+int AccessPointDiffApp::command(int argc, const char * const * argv)
+{
+	if (argc > 2)
+	{
+		if (!strcmp(argv[1], "subscribe"))
+			return execTclSubscribe(argc - 2, argv + 2);
+	}
+
+	return DiffApp::command(argc, argv);
+}
+
+// Receive a packet from diffusion protocol
+void AccessPointDiffApp::recv(NRAttrVec * data, NR::handle my_handle)
+{
+	NRSimpleAttribute<int> * nrClass;
+
+	nrClass = NRClassAttr.find(data);
+
+	if (!nrClass)
+	{
+		fprintf(stderr, "Received a bad diffusion packet!");
+		abort();
+	}
+
+	switch (nrClass->getVal())
+	{
+		case NRAttribute::INTEREST_CLASS:
+			printf("Access point received an Interest message!\n");
+			break;
+
+		case NRAttribute::DISINTEREST_CLASS:
+			printf("Access point received a Disinterest message!\n");
+			break;
+
+		case NRAttribute::DATA_CLASS:
+			printf("*** Access point received a Data message!\n");
+			recvData(data, my_handle);
+			break;
+	}
+}
+
+// Receive a data message
+void AccessPointDiffApp::recvData(NRAttrVec * data, NR::handle my_handle)
+{
+	NRSimpleAttribute<AppDataType> * nrAppDataType;
+
+	nrAppDataType = AppDataTypeAttr.find(data);
+
+	if (!nrAppDataType)
+	{
+		fprintf(stderr, "Bad data message!");
+		abort();
+	}
+
+	printf("Data message contains application data type %d.\n",
+		nrAppDataType->getVal());
+
+	switch (nrAppDataType->getVal())
+	{
+		case SENSED_DATA:
+			recvSensedData(data, my_handle);
+			break;
+
+		default:
+			recvSpecificSensedData(nrAppDataType->getVal(), data, my_handle);
+			break;
+	}
+}
+
+void AccessPointDiffApp::recvSensedData(NRAttrVec * data, handle h)
+{
+	NRSimpleAttribute<AppData *>   * nrSensedData;
+	SensedData *                     sensedData;
+
+	/* Look for sensed data */
+	nrSensedData = SensedDataAttr.find(data);
+
+	if (nrSensedData)
+	{
+		AppDataList list;
+
+		sensedData = (SensedData *) (nrSensedData->getVal());
+		list       = sensedData->getData();
+	
+		printf("<<Received %d elements>>", list.size());
+
+		for (AppDataList::iterator it = list.begin();
+			it != list.end();
+			it++)
+		{
+			switch ((*it)->type())
+			{
+				case TEMPERATURE_SENSED_DATA:
+					printf("  Temperature: %lf on %lf\n",
+						((TemperatureAppData *) *it)->data(),
+						((TemperatureAppData *) *it)->time());
+					break;
+
+				default:
+					printf("  Unknown data type %d!\n",
+						(*it)->type());
+					printf("  FORCANDO Temperature: %lf on %lf\n",
+						((TemperatureAppData *) *it)->data(),
+						((TemperatureAppData *) *it)->time());
+					break;
+			}
+		}
+	}
+	else
+    {
+		printf("AccessPointDiffApp::recvSensedData - There are no sensed data!\n");
+    }
+}
+
+void AccessPointDiffApp::recvSpecificSensedData(AppDataType type, NRAttrVec * data, handle h)
+{
+	NRSimpleAttribute<double> * nrValue;
+	NRSimpleAttribute<float>  * nrTimeStamp;
+	NRSimpleAttribute<int>    * nrNodeID;
+
+	nrValue     = SensedValueAttr.find(data);
+	nrTimeStamp = TimeStampAttr.find(data);
+	nrNodeID    = NodeIDAttr.find(data);
+
+	printf("@ Received from node %d with %lf delay ::: %lf %lf\n", nrNodeID->getVal(), Scheduler::instance().clock() - nrTimeStamp->getVal(), nrTimeStamp->getVal(), Scheduler::instance().clock());
+
+	switch (type)
+	{
+		case TEMPERATURE_SENSED_DATA:
+			printf("<< Temperature: %lf >>\n", nrValue->getVal());
+			break;
+
+		default:
+			printf("<< UNKNOWN TYPE: %lf >>\n", nrValue->getVal());
+			break;
+	}
+}
+
+// Subscribe to an interest
+handle AccessPointDiffApp::subscribe(AppDataType appDataType, NRAttribute::operators op, double value)
+{
+	NRAttrVec attrs;
+	handle    hnd;
+
+	printf("Access point subscribed to application data type %d.\n", appDataType);
+
+	attrs.push_back(
+		NRClassAttr.make(NRAttribute::IS, NRAttribute::INTEREST_CLASS));
+
+	attrs.push_back(AppDataTypeAttr.make(NRAttribute::EQ, appDataType));
+
+	attrs.push_back(SensedValueAttr.make(op, value));
+
+	hnd = dr_->subscribe(&attrs, this);
+
+	ClearAttrs(&attrs);
+
+	return hnd;
+}
+
+/*****************************************************************/
+/* Tcl Commands                                                  */
+/*****************************************************************/
+
+int AccessPointDiffApp::execTclSubscribe(int argc, const char * const * argv)
+{
+	AppDataType             type;
+	NRAttribute::operators  op;
+	double                  value;
+
+	if (argc < 2 || argc > 3)
+	{
+		fprintf(stderr, "SINTAXE: subscribe <type> <operator> [value]\n\n"
+				"<operator> can be:\n"
+				"    =     Equal\n"
+				"    >     Greater than\n"
+				"    <     Lesser than\n"
+				"    !=    Not equal\n"
+				"    >=    Greater or equal\n"
+				"    <=    Lesser or equal\n"
+				"    *     Any\n");
+	}
+
+	type = (AppDataType) atoi(argv[0]);
+
+	if (argv[1][1] == 0)
+	{
+		switch (argv[1][0])
+		{
+			case '=':
+				op = NRAttribute::EQ;
+				break;
+	
+			case '>':
+				op = NRAttribute::GT;
+				break;
+
+			case '<':
+				op = NRAttribute::LT;
+				break;
+
+			case '*':
+				op = NRAttribute::EQ_ANY;
+				break;
+
+			default:
+				return TCL_ERROR;
+		}
+	}
+	else if (argv[1][2] == 0)
+	{
+		if (argv[1][1] == '=')
+		{
+			switch (argv[1][0])
+			{
+				case '!':
+					op = NRAttribute::NE;
+					break;
+
+				case '>':
+					op = NRAttribute::GE;
+					break;
+
+				case '<':
+					op = NRAttribute::LE;
+					break;
+
+				default:
+					return TCL_ERROR;
+			}
+		}
+		else
+			return TCL_ERROR;
+	}
+	else
+		return TCL_ERROR;
+
+	if (argc == 3)
+		value = atof(argv[2]);
+
+	else if (op != NRAttribute::EQ_ANY)
+		return TCL_ERROR;
+
+	subscribe(type, op, value);
+
+	return TCL_OK;
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/accessPointDiffApp.h ns-allinone-2.35/ns-2.35/mannasim/diffusion/accessPointDiffApp.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/accessPointDiffApp.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/diffusion/accessPointDiffApp.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,39 @@
+#ifndef _ACCESSPOINTDIFFAPP_H_
+#define _ACCESSPOINTDIFFAPP_H_
+
+#include "nrAttributes.h"
+#include "../sensorBaseApp.h"
+#include "../temperatureAppData.h"
+
+/* AccessPointDiffApp
+ * -- J�lio C�sar e Melo <julio.melo@gmail.com>
+ *
+ * This is a class for access point using directed diffusion.
+ */
+class AccessPointDiffApp : public DiffApp, NR::Callback
+{
+	public:
+		AccessPointDiffApp();
+
+		void run() {};
+		virtual int command(int argc, const char * const * argv);
+
+		// Receive message from directed diffusion
+		void recv(NRAttrVec * data, NR::handle my_handle);
+
+	protected:
+		// Subscribe for an interest
+		handle subscribe(AppDataType appDataType, NRAttribute::operators op, double value);
+		
+		// Receive sensed data
+		virtual void recvSensedData(NRAttrVec *, NR::handle);
+		virtual void recvSpecificSensedData(AppDataType type, NRAttrVec *, NR::handle);
+
+	private:
+		virtual void recvData(NRAttrVec * data, NR::handle my_handle);
+
+		// Execute Tcl Management Commands
+		int execTclSubscribe(int argc, const char * const *);
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/attrsExporter.h ns-allinone-2.35/ns-2.35/mannasim/diffusion/attrsExporter.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/attrsExporter.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/diffusion/attrsExporter.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,33 @@
+#ifndef _ATTRSEXPORTER_H_
+#define _ATTRSEXPORTER_H_
+
+#include <nr.hh>
+#include "nrAttributes.h"
+
+/* AppDataAttrsExporter
+ * -- J�lio C�sar e Melo <julio.melo@gmail.com>
+ *
+ * This is a interface for any sensed data sent
+ * by CommonNodeDiffApp.
+ *
+ * First idea was to implements a interface called
+ * AttrsExporter and to multiple-inherits the sensed
+ * data (AppData and AttrsExporter).
+ *
+ * As multiple-inheritance may cause calling virtual
+ * function problems, AppDataAttrsExporter inherits
+ * from AppData.
+ */
+class AppDataAttrsExporter : public AppData
+{
+	public:
+		AppDataAttrsExporter(AppDataType type) : AppData(type)
+		{ }
+
+		/* Set attributes on attributes vector */
+		virtual void setAttributes(NRAttrVec * attrs) = 0;
+};
+
+typedef AppDataAttrsExporter AttrsExporter;
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/commonNodeDiffApp.cc ns-allinone-2.35/ns-2.35/mannasim/diffusion/commonNodeDiffApp.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/commonNodeDiffApp.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/diffusion/commonNodeDiffApp.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,360 @@
+/* CommonNodeDiffApp.cc
+ * -- J�lio C�sar e Melo <julio.melo@gmail.com>
+ *
+ * Implementation of CommonNodeDiffApp.
+ * It is a class for common sensor node, using
+ * directed diffusion.
+ */
+
+#include "commonNodeDiffApp.h"
+#include <common/ns-process.h>
+#include <stdexcept>
+
+// Provides an instance of the CommonNodeDiffApp class in the simulation script
+static class CommonNodeDiffAppClass : public TclClass
+{
+	public:
+		CommonNodeDiffAppClass() : TclClass("Application/SensorBaseApp/CommonNodeDiffApp") {}
+
+		TclObject * create(int, const char * const *)
+		{
+			return new CommonNodeDiffApp::TclObjectAdaptor();
+		}
+} class_common_node_diff_app;
+
+/**************************************************************************/
+
+// Constructor
+CommonNodeDiffApp::CommonNodeDiffApp()
+{
+}
+
+// Destructor
+CommonNodeDiffApp::~CommonNodeDiffApp()
+{
+	PublishedDataList::iterator it;
+
+	for (it = publishedDataList_.begin(); it != publishedDataList_.end(); it++)
+		dr_->unpublish((*it)->hnd);
+}
+
+// Overrides CommonNodeApp's function
+void CommonNodeDiffApp::insertNewGenerator(DataGenerator * gen)
+{
+	CommonNodeApp::insertNewGenerator(gen);
+
+	publishData(gen->type());
+}
+
+/* Overrides CommonNodeApp's function
+ *
+ * This is called to disseminateData from sensor node.
+ */
+void CommonNodeDiffApp::disseminateData(SensedData * data)
+{
+	if (data)
+	{
+		NRAttrVec       attrs;
+		PublishedData * pubData;
+		AppDataList     list;
+
+		list = data->getData();
+
+		printf("Common Node %d"
+			" - Disseminating %d datas\n",
+			sensor_node_->nodeid(),
+			list.size());
+
+		// Send each sensed data using directed diffusion
+		for (AppDataList::iterator it = list.begin();
+			it != list.end();
+			it++)
+		{
+			pubData = publishData((*it)->type(), (AttrsExporter *) (*it));
+
+			attrs.push_back(
+				TimeStampAttr.make(NRAttribute::IS, Scheduler::instance().clock()));
+
+/*			if (interested(&attrs))
+			{
+				printf("Common Node %d"
+					" - Disseminating %d datas\n",
+					sensor_node_->nodeid(),
+					list.size());
+			}
+
+*/			if (dr_->send(pubData->hnd, &attrs) == FAIL)
+			{
+				fprintf(stderr, "bug! CommonNodeDiffApp::publishData\n");
+				//abort();
+                exit(1);
+			}
+
+			ClearAttrs(&attrs);
+		}
+	}
+}
+
+/* Find a handle to a published data generetador */
+CommonNodeDiffApp::PublishedData * CommonNodeDiffApp::findPublishedData(AppDataType appDataType)
+{
+	PublishedDataList::iterator it;
+
+	it = publishedDataList_.begin();
+
+	while (it != publishedDataList_.end())
+	{
+		if ((*it)->appDataType == appDataType)
+			return *it;
+
+		it++;
+	}
+
+	fprintf(stderr,
+		"Unable to find AppDataType for specific sensed data!\n");
+
+	//throw runtime_error("AppDataType not found for specific sensed data!");
+	//abort();
+    exit(1);
+}
+
+/* Publish data.
+ *
+ * This is called for the first publication, which occurs
+ * on data generator attachment.
+ */
+CommonNodeDiffApp::PublishedData * CommonNodeDiffApp::publishData(
+	AppDataType appDataType,
+	NR::Callback * receiver)
+{
+	NRAttrVec     attrs;
+	PublishedData * my_publishedData;
+
+	// Set attributes and publish it for data generator
+	attrs.push_back(
+		NRClassAttr.make(NRAttribute::IS, NRAttribute::DATA_CLASS));
+
+	attrs.push_back(
+		AppDataTypeAttr.make(NRAttribute::IS, appDataType));
+
+	attrs.push_back(
+		NodeIDAttr.make(NRAttribute::IS, this->sensor_node_->nodeid()));
+
+	// Publish data
+	my_publishedData                = new PublishedData;
+	my_publishedData->hnd           = dr_->publish(&attrs);
+	my_publishedData->appDataType   = appDataType;
+	my_publishedData->subscriptions = 0;
+
+	ClearAttrs(&attrs);
+
+	publishedDataList_.push_back(my_publishedData);
+
+	// Create subscription handler
+	if (!receiver)
+		my_publishedData->receiver = new InterestReceiver(
+			this, my_publishedData);
+	else
+		my_publishedData->receiver = receiver;
+
+	subscribePublishedData(my_publishedData);
+
+	return my_publishedData;
+}
+
+/* Publish sensed data.
+ *
+ * This function searches for previous publishe data
+ * with the same AppDataType and re-publish it,
+ * containing a new sensed data value.
+ *
+ * This is usefull to access point subscribe for
+ * conditional sensed data (i.e. temperature > 30).
+ */
+CommonNodeDiffApp::PublishedData * CommonNodeDiffApp::publishData(AppDataType appDataType, AttrsExporter * attrsExporter)
+{
+	NRAttrVec     attrs;
+	PublishedData * my_publishedData;
+
+	// Set attributes and publish it for data generator
+	attrs.push_back(
+		NRClassAttr.make(NRAttribute::IS, NRAttribute::DATA_CLASS));
+
+	attrs.push_back(
+		AppDataTypeAttr.make(NRAttribute::IS, appDataType));
+
+	attrs.push_back(
+		NodeIDAttr.make(NRAttribute::IS, this->sensor_node_->nodeid()));
+
+	attrsExporter->setAttributes(&attrs);
+
+	// Unpublish previous data
+	my_publishedData                = findPublishedData(appDataType);
+
+	dr_->unpublish(my_publishedData->hnd);
+
+	my_publishedData->hnd           = dr_->publish(&attrs);
+	my_publishedData->subscriptions = 0;
+
+	ClearAttrs(&attrs);
+
+	return my_publishedData;
+}
+
+/* subscribePublishedData(pubData)
+ * - pubData: Subscribe to receive subscriptions and unsubscriptions
+ */
+void CommonNodeDiffApp::subscribePublishedData(PublishedData * pubData)
+{
+	NRAttrVec attrs;
+
+	attrs.push_back(
+		NRClassAttr.make(NRAttribute::NE, NRAttribute::DATA_CLASS));
+
+	attrs.push_back(
+		NRScopeAttr.make(NRAttribute::IS, NRAttribute::NODE_LOCAL_SCOPE));	
+
+//	attrs.push_back(
+//		AppDataTypeAttr.make(NRAttribute::EQ, pubData->appDataType));
+
+//	attrs.push_back(
+//		NodeIDAttr.make(NRAttribute::EQ, this->sensor_node_->nodeid()));
+
+	dr_->subscribe(&attrs, pubData->receiver);
+
+	ClearAttrs(&attrs);
+}
+
+void CommonNodeDiffApp::run()
+{
+	// Insert generic sensed data
+	publishData(SENSED_DATA);
+}
+
+void CommonNodeDiffApp::start()
+{
+	DiffApp::start();
+	CommonNodeApp::start();
+
+	run();
+}
+
+/* * * Event handle * * */
+
+// Occurs when someone subscribes
+void CommonNodeDiffApp::onSubscription(PublishedData * pubData, NRAttrVec * data)
+{
+	NRSimpleAttribute<AppDataType> * appDataType;
+
+	appDataType = AppDataTypeAttr.find(data);
+
+	if (!appDataType)
+		printf("Common Node %d received an Interest message!\n",
+			sensor_node_->nodeid());
+
+	else
+		printf("Common Node %d received an Interest message for app data %d\n",
+			sensor_node_->nodeid(), appDataType->getVal());
+
+	subscriptions_.push_back(CopyAttrs(data));
+}
+
+void CommonNodeDiffApp::onUnsubscription(PublishedData * pubData, NRAttrVec * data)
+{
+	NRAVList::iterator it;
+
+	printf("Common Node %d received an Disinterest message!\n",
+		sensor_node_->nodeid());
+
+	for (it = subscriptions_.begin(); it != subscriptions_.end(); it++)
+		if (PerfectMatch(data, *it))
+		{
+			NRAttrVec * tmp = *it;
+
+			subscriptions_.remove(*it);
+
+			delete tmp;
+
+			return;
+		}
+}
+
+/*************************************************************************
+ * Interest receiver class                                               *
+ *                                                                       *
+ * This class is used to handle Interest messages.                       *
+ *************************************************************************/
+
+CommonNodeDiffApp::InterestReceiver::InterestReceiver(CommonNodeDiffApp * node, PublishedData * pubData)
+{
+	this->node_    = node;
+	this->pubData_ = pubData;
+}
+
+void CommonNodeDiffApp::InterestReceiver::recv(NRAttrVec * data, NR::handle hnd)
+{
+	NRSimpleAttribute<int> * nrClass;
+	NRSimpleAttribute<AppDataType> * nrAppDataType;
+
+	// Get message's class and validate it
+	nrClass = NRClassAttr.find(data);
+
+	if (!nrClass)
+	{
+		fprintf(stderr, "Received a bad diffusion packet!\n");
+		//abort();
+        exit(1);
+	}
+
+//	printf("AIEEEEEEEE!\n");
+
+	nrAppDataType = AppDataTypeAttr.find(data);
+
+//	assert(nrAppDataType && nrAppDataType->getVal() == pubData_->appDataType);
+
+/*	if (!nrAppDataType)
+	{
+		fprintf(stderr, "Not a valid packet for InterestReceiver!\n");
+		abort();
+	}
+	else if (nrAppDataType->getVal() != pubData_->appDataType)
+	{
+		fprintf(stderr,
+			"Received a not expected application data type (%d != %d)"
+			" message on SensedDataInterestReceiver!\n",
+			nrAppDataType->getVal(),
+			pubData_->appDataType);
+		abort();
+	}
+*/
+	switch (nrClass->getVal())
+	{
+		case NRAttribute::INTEREST_CLASS:
+			pubData_->subscriptions++;
+			node_->onSubscription(pubData_, data);
+			break;
+
+		case NRAttribute::DISINTEREST_CLASS:
+			pubData_->subscriptions--;
+			node_->onUnsubscription(pubData_, data);
+			break;
+	}
+}
+
+bool CommonNodeDiffApp::interested(NRAttrVec * data)
+{
+	NRAVList::iterator it;
+
+	for (it = subscriptions_.begin(); it != subscriptions_.end(); it++)
+	{
+		NRAttrVec * attrs = *it;
+
+		PrintAttrs(attrs);
+		PrintAttrs(data);
+
+		if (OneWayMatch(attrs, data))
+			return true;
+	}
+
+	return false;
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/commonNodeDiffApp.h ns-allinone-2.35/ns-2.35/mannasim/diffusion/commonNodeDiffApp.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/commonNodeDiffApp.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/diffusion/commonNodeDiffApp.h	2009-11-12 15:43:37.000000000 +0100
@@ -0,0 +1,183 @@
+/* Implemented by Julio Cesar e Melo <cmelo_bhz@hotmail.com> */
+
+#ifndef _COMMONNODEDIFFAPP_H_
+#define _COMMONNODEDIFFAPP_H_
+
+#include <list>
+#include <stdlib.h>
+
+#include "nrAttributes.h"
+#include "attrsExporter.h"
+#include "../commonNodeApp.h"
+
+using namespace std;
+
+/* CommonNodeDiffApp
+ * -- J�lio C�sar e Melo
+ *
+ * This is a class for a common sensor node.
+ * It inherits from CommonNodeApp (from MannaSIM)
+ * and DiffApp. As both are applications and inherit
+ * from TclObject, there are some ambiguous virtual
+ * functions. To solve this problem, it was implemented
+ * an adaptor for calling the specific functions of
+ * each ancestor (see CommonNodeApp::TclObjectAdaptor).
+ */
+class CommonNodeDiffApp : public DiffApp, CommonNodeApp
+{
+	private:
+		class SensedDataInterestReceiver;
+
+	public:
+		/* Type definitions */
+		struct PublishedData
+		{
+			handle             hnd;
+			AppDataType        appDataType;
+			int                subscriptions;
+			NR::Callback *     receiver;
+		};
+	
+		typedef list<PublishedData *> PublishedDataList;
+		typedef list<NRAttrVec *>       NRAVList;
+
+		// Subscribe for receiving interest message
+		void subscribePublishedData(PublishedData *);
+
+	protected:
+		// List of published datas
+		PublishedDataList publishedDataList_;
+
+		// List of attribute list
+		NRAVList subscriptions_;
+
+		// Publish an application data type
+		PublishedData * publishData(AppDataType appDataType, NR::Callback * receiver = NULL);
+		PublishedData * publishData(AppDataType appDataType, AttrsExporter * attrsExporter);
+	
+		// Find a published data
+		PublishedData * findPublishedData(AppDataType appDataType);
+
+		// Occurs when received a subscription
+		virtual void onSubscription(PublishedData *, NRAttrVec *);
+
+		// Occurs when received a unsubscription
+		virtual void onUnsubscription(PublishedData *, NRAttrVec *);
+
+		// Check if there is someone interested
+		bool interested(NRAttrVec *);
+
+	public:
+		// Public constructors and destructors
+		CommonNodeDiffApp();
+		~CommonNodeDiffApp();
+	
+		virtual void start();
+		virtual void run();
+	
+		// Disseminate processed data from sensor node
+		virtual void disseminateData(SensedData * data_);
+	
+		// Attach a new data generator
+		virtual void insertNewGenerator(DataGenerator * gen);
+
+		/*****************************/
+		/***** Ambiguous methods *****/
+		/*****************************/
+
+		virtual int command(int argc, const char * const * argv)
+		{
+			int result;
+
+			result = CommonNodeApp::command(argc, argv);
+
+			if (result == TCL_OK)
+				return result;
+
+			result = DiffApp::command(argc, argv);
+
+			return result;
+		}
+
+		virtual void trace(TracedVar *tv)
+		{
+			CommonNodeApp::trace(tv);
+		}
+
+		virtual int init(int argc, const char * const * argv)
+		{
+			CommonNodeApp::init(argc, argv);
+		}
+
+		virtual int delay_bind_dispatch(const char * varName, const char * localName, TclObject * tracer)
+		{
+			CommonNodeApp::delay_bind_dispatch(varName, localName, tracer);
+		}
+
+		virtual void delay_bind_init_all()
+		{
+			CommonNodeApp::delay_bind_init_all();
+		}
+
+                /* Adaptor - Necessary to remove ambiguous from base
+                 * TclObject class
+                 */
+		class TclObjectAdaptor : public TclObject
+		{
+		private:
+			CommonNodeDiffApp * obj_;
+
+		public:
+			TclObjectAdaptor()
+			{
+				obj_ = new CommonNodeDiffApp();
+			}
+
+			~TclObjectAdaptor()
+			{
+				delete obj_;
+			}
+
+			virtual int command(int argc, const char * const * argv)
+			{
+				obj_->command(argc, argv);
+			}
+
+			virtual void trace(TracedVar *tv)
+			{
+				obj_->trace(tv);
+			}
+
+			virtual int init(int argc, const char * const * argv)
+			{
+				obj_->init(argc, argv);
+			}
+
+			virtual int delay_bind_dispatch(const char * varName, const char * localName, TclObject * tracer)
+			{
+				obj_->delay_bind_dispatch(varName, localName, tracer);
+			}
+
+			virtual void delay_bind_init_all()
+			{
+				obj_->delay_bind_init_all();
+			}
+		};
+
+	private:
+		/* Interest receiver */
+		class InterestReceiver : public NR::Callback
+		{
+			private:
+				PublishedData     * pubData_;
+				CommonNodeDiffApp * node_;
+
+			public:
+				InterestReceiver(
+					CommonNodeDiffApp *, PublishedData *);
+
+				void recv(NRAttrVec *, NR::handle);
+		};
+};
+	
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/mannanmp.cc ns-allinone-2.35/ns-2.35/mannasim/diffusion/mannanmp.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/mannanmp.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/diffusion/mannanmp.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,186 @@
+/* MannaNMP.cc
+ * -- J�lio C�sar e Melo <julio.melo@gmail.com>
+ *
+ * Implementation of MannaNMPAgent, a class for
+ * MannaNMP protocol using directed diffusion.
+ */
+#include "../management/managementData.h"
+#include "mannanmp.h"
+#include <assert.h>
+#include <dr.hh>
+
+using namespace mib;
+
+/* Constructs the agent */
+MannaNMPAgent::MannaNMPAgent(MIBTable * mib, NR * dr)
+{
+	assert(mib && dr);
+
+	this->mib_ = mib;
+	this->dr_  = dr;
+}
+
+/* Receive data from directed diffusion */
+void MannaNMPAgent::recv(NRAttrVec * data, handle h)
+{
+	NRSimpleAttribute<int> * nrClass;
+
+	// Get message's class and validate it
+	nrClass = NRClassAttr.find(data);
+
+	if (!nrClass)
+	{
+		fprintf(stderr, "Received a bad diffusion packet!\n");
+		abort();
+	}
+
+	switch (nrClass->getVal())
+	{
+		case NRAttribute::INTEREST_CLASS:
+			onSubscription(data, h);
+			break;
+
+		case NRAttribute::DISINTEREST_CLASS:
+			// Nothing here until this moment
+			break;
+	}
+}
+
+/* Occurs when received a subscription */
+void MannaNMPAgent::onSubscription(NRAttrVec * data, handle h)
+{
+	NRSimpleAttribute<ManagementData *> * messageAttr;
+	ManagementData *                      message;
+
+	// Get management data
+	messageAttr = ManagementRequestAttr.find(data);
+
+	assert(messageAttr != NULL);
+
+	if (messageAttr == NULL)
+	{
+		fprintf(stderr, "Como assim 1?\n");
+		abort();
+	}
+
+	message = messageAttr->getVal();
+
+	assert(message != NULL);
+
+	if (message == NULL)
+	{
+		fprintf(stderr, "Como assim 2?\n");
+		abort();
+	}
+
+	switch (message->getOperation())
+	{
+		case GET:
+			printf("MANNANMP: GET\n");
+			onGetMessage((GetData *) message, h);
+			break;
+
+		case SET:
+			printf("MANNANMP: SET\n");
+			onSetMessage((SetData *) message, h);
+			break;
+
+		case RESPONSE:
+		case TRAP:
+			fprintf(stderr,
+				"Agent shouldn't receive a RESPONSE or TRAP"
+				" message!\n");
+			abort();
+
+		default:
+			fprintf(stderr,
+				"Unknown management operation %d!\n",
+				message->getOperation());
+			abort();
+	}
+}
+
+/* onGetMessage(message, h)
+ *
+ * Occurs when received a get message.
+ */
+void MannaNMPAgent::onGetMessage(GetData * message, handle h)
+{
+	NRAttrVec             attrs;          // Attributes of diffusion message
+	KeyValueData          data(RESPONSE); // Response data
+	GetData::MIBKeyList * requestList;
+	ManagementData *      dataCopy;
+
+	requestList = message->getRequestList();
+
+	printf("Sending response for key(s)");
+	
+	for (GetData::MIBKeyList::iterator it = requestList->begin();
+		it != requestList->end();
+		it++)
+	{
+		mibKey         key = *it;
+		MIBEntryBase * entry = mib_->getEntry(key)->copy();
+
+		data.addEntry(entry);
+
+		// DEBUG!!!
+		printf(" %d = ", key);
+
+		switch (entry->getType())
+		{
+			case INT32:
+				printf("%d (INT32)", ((MIBEntry<int> *) entry)->getValue());
+				break;
+
+			case LONG:
+				printf("%ld (LONG)", ((MIBEntry<long> *) entry)->getValue());
+				break;
+
+			case FLOAT:
+				printf("%f (FLOAT)", ((MIBEntry<float> *) entry)->getValue());
+				break;
+
+			case DOUBLE:
+				printf("%lf (DOUBLE)", ((MIBEntry<double> *) entry)->getValue());
+				break;
+		}
+	}
+
+	printf(".\n");
+
+	dataCopy = (ManagementData *) data.copy();
+
+	attrs.push_back(
+		ManagementResponseAttr.make(
+			NRAttribute::IS, dataCopy));
+
+	dr_->send(hnd_, &attrs);
+
+	ClearAttrs(&attrs);
+}
+
+/* Occurs when received a set message */
+void MannaNMPAgent::onSetMessage(SetData * message, handle h)
+{
+	SetData::MIBEntryList * list;
+	char                    buf[32];
+
+	list = message->getEntries();
+
+	for (SetData::MIBEntryList::iterator it = list->begin(); it != list->end(); it++)
+	{
+		mibKey         key;
+		MIBEntryBase * entry;
+
+		key   = (*it)->getKey();
+		entry = mib_->getEntry(key);
+
+		(*it)->toString(buf);
+
+		printf("     Setting %d = %s\n", key, buf);
+
+		entry->setValue(buf);
+	}
+}
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/mannanmp.h ns-allinone-2.35/ns-2.35/mannasim/diffusion/mannanmp.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/mannanmp.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/diffusion/mannanmp.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,32 @@
+/* mannanmp.h
+ * -- J�lio C�sar e Melo <julio.melo@gmail.com>
+ *
+ * MannaNMPAgent is a class for answering
+ * MannaNMP messages using directed diffusion.
+ */
+#ifndef _MANNANMP_H_
+#define _MANNANMP_H_
+
+#include "nrAttributes.h"
+#include "../management/mibTable.h"
+#include <nr.hh>
+
+class MannaNMPAgent : public NR::Callback
+{
+	protected:
+		MIBTable *   mib_;
+		NR *         dr_;
+		handle       hnd_;
+
+	public:
+		MannaNMPAgent(MIBTable * mib, NR * dr);
+		void recv(NRAttrVec * data, handle h);
+		void setHandle(handle h) { hnd_ = h; }
+
+	private:
+		void onSubscription(NRAttrVec * data, handle h);
+		void onGetMessage(GetData * message, handle h);
+		void onSetMessage(SetData * message, handle h);
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/nrAttributes.cc ns-allinone-2.35/ns-2.35/mannasim/diffusion/nrAttributes.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/nrAttributes.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/diffusion/nrAttributes.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,55 @@
+/* nrAttributes.cc
+ * -- J�lio C�sar e Melo <julio.melo@gmail.com>
+ *
+ * This file contains implementation for Directed Diffusion
+ * attributes for using by MannaSIM.
+ */
+#define _NRATTRIBUTES_CC_
+
+#include "nrAttributes.h"
+#include <stdlib.h>
+
+NRSimpleAttribute<AppData *>::NRSimpleAttribute(int key, int type, int op, AppData * val, int size)
+	: NRAttribute(key, BLOB_TYPE, op, 0)
+{
+	assert(type == BLOB_TYPE);
+
+	val_ = NULL;
+	setVal(val, val->size());
+}
+
+NRSimpleAttribute<AppData *>::~NRSimpleAttribute()
+{
+	delete [] (char *) val_;
+}
+
+void NRSimpleAttribute<AppData *>::setVal(AppData * value, int len)
+{
+	delete [] (char *) val_;
+	len_ = len;
+	val_ = (void *) new char[len_];
+	memcpy(val_, value, len_);
+}
+
+AppData * NRSimpleAttribute<AppData *>::getVal()
+{
+	return (AppData *) val_;
+}
+
+/***************************************************************************/
+/* Atributes */
+
+NRSimpleAttributeFactory<AppDataType> AppDataTypeAttr(
+	APPLICATION_DATA_TYPE, NRAttribute::INT32_TYPE);
+
+NRSimpleAttributeFactory<int> NodeIDAttr(
+	NODE_ID, NRAttribute::INT32_TYPE);
+
+NRSimpleAttributeFactory<AppData *>   SensedDataAttr(
+	SENSED_DATA_BLOB, NRAttribute::BLOB_TYPE);
+
+NRSimpleAttributeFactory<double> SensedValueAttr(SENSED_VALUE, NRAttribute::FLOAT64_TYPE);
+
+NRSimpleAttributeFactory<float> TimeStampAttr(TIME_STAMP, NRAttribute::FLOAT32_TYPE);
+
+#undef _NRATTRIBUTES_CC_
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/nrAttributes.h ns-allinone-2.35/ns-2.35/mannasim/diffusion/nrAttributes.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/diffusion/nrAttributes.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/diffusion/nrAttributes.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,40 @@
+/* nrAttributes.h
+ * -- J�lio C�sar e Melo <julio.melo@gmail.com>
+ *
+ * This file contains definition for Directed Diffusion
+ * attributes for using by MannaSIM.
+ */
+#ifndef _NRATTRIBUTES_H_
+#define _NRATTRIBUTES_H_
+
+#include "diffapp.hh"
+#include "config.h"
+
+template <> class NRSimpleAttribute<AppData *> : public NRAttribute
+{
+	public:
+		NRSimpleAttribute(int key, int type, int op, AppData * val, int size = 0);
+		~NRSimpleAttribute();
+
+		void setVal(AppData * value, int len);
+		AppData * getVal();
+};
+
+enum keys
+{
+	APPLICATION_DATA_TYPE = 3000,
+	NODE_ID,
+	SENSED_DATA_BLOB,
+	SENSED_VALUE,
+	TIME_STAMP
+};
+
+#ifndef _NRATTRIBUTES_CC_
+extern NRSimpleAttributeFactory<AppDataType>      AppDataTypeAttr;
+extern NRSimpleAttributeFactory<int>              NodeIDAttr;
+extern NRSimpleAttributeFactory<AppData *>        SensedDataAttr;
+extern NRSimpleAttributeFactory<double>		  SensedValueAttr;
+extern NRSimpleAttributeFactory<float>            TimeStampAttr;
+#endif
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/app/accessPointLeachApp.cc ns-allinone-2.35/ns-2.35/mannasim/leach/app/accessPointLeachApp.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/app/accessPointLeachApp.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/app/accessPointLeachApp.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,42 @@
+#include "accessPointLeachApp.h"
+#include <mannasim/leach/leachAgent.h>
+
+static class AccessPointLeachAppClass : public TclClass
+{
+	public:
+		AccessPointLeachAppClass() : TclClass("Application/AccessPointApp/AccessPointLeachApp") {}
+
+		TclObject* create(int, const char*const*)
+		{
+			return (new AccessPointLeachApp());
+		}
+} class_accesspointleachapp;
+
+
+
+void AccessPointLeachApp::start()
+{
+	if (agent_ == NULL)
+	{
+		char agentName[32];
+
+		printf("Warning! AccessPointLeachApp::start() => Agent is null! Creating a LeachAgent!\n");
+
+		sprintf(agentName, "__apagent"); // N�o est� legal
+
+		agent_ = new LeachAgent();
+		agent_->name(agentName);
+
+		Tcl::instance().enter(agent_);
+
+		printf("%s attach %s", name(), agent_->name());
+		Tcl::instance().evalf("%s attach %s", name(), agent_->name());
+	}
+
+	AccessPointApp::start();
+}
+
+void AccessPointLeachApp::forward_data(int size, AppData * data)
+{
+	// Por enquanto nada... ver compatibilidade depois ***
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/app/accessPointLeachApp.h ns-allinone-2.35/ns-2.35/mannasim/leach/app/accessPointLeachApp.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/app/accessPointLeachApp.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/app/accessPointLeachApp.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,26 @@
+#ifndef _ACCESSPOINTLEACHAPP_H_
+#define _ACCESSPOINTLEACHAPP_H_
+
+#include "../../accessPointApp.h"
+
+/* AccessPointLeachApp
+ * -- J�lio C�sar e Melo <julio.melo@gmail.com>
+ *
+ * This is a class for access point using leach.
+ */
+class AccessPointLeachApp : public AccessPointApp {
+
+	public:
+		// Method called from the transport protocol for the application to 
+		// receive a message. Method from Process (ns-process.cc) overcharged
+//		virtual void process_data(int size, AppData* data);
+
+//		int command(int argc, const char*const* argv);
+//		virtual void stop();
+		virtual void start();
+
+		virtual void forward_data(int size, AppData* data);	
+};
+
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/app/leachApp.cc ns-allinone-2.35/ns-2.35/mannasim/leach/app/leachApp.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/app/leachApp.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/app/leachApp.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,813 @@
+#include "leachApp.h"
+#include <random.h>
+#include <mannasim/battery.h>
+#include <mannasim/leach/rca/rcagent.h>
+
+/** TCL **************************************/
+
+static class LeachAppClass : public TclClass
+{
+        public:
+                LeachAppClass() : TclClass("Application/SensorBaseApp/CommonNodeApp/LeachApp") {}
+ 
+                // Create a TCL Object (parameters starts in 4)
+                TclObject * create(int argc, const char * const * argv)
+                {
+			if (argc != 7)
+			{
+				fprintf(stderr,
+					"Incorrect sintax:\n"
+					"  new LeachApp <nNodes> <nClusters> <maxDist>");
+			}
+
+                        return new LeachApp(
+                                atoi(argv[4]),
+                                atoi(argv[5]),
+				atof(argv[6]));
+                }
+} leach_app_object;
+ 
+
+
+
+/*********************************************/
+
+LeachApp::LeachApp(int nNodes, int nClusters, double maxDist) : CommonNodeApp() // : SensorBaseApp()
+{
+	mac_			 = NULL;
+	agent_                   = NULL;
+
+	isCH_                    = 0;
+	hasBeenCH_               = false;
+	nextChangeTime_          = 0;
+	round_                   = 0;
+	dist_                    = 0;
+	code_                    = 0;
+	now_                     = 0;
+	endFrmTime_              = 0;
+	beginIdle_               = 0;
+	beginSleep_              = 0;
+
+	/* Although constructing here, can't determine
+	 * sensedData's nodeid, because while constructing
+	 * the sensed_node_ is not yet defined.
+	 */
+	sensedData_              = new SensedData();
+
+	eventHandler_            = new LeachEventHandler(this);
+
+	config_.numberNodes_     = nNodes;
+	config_.desiredClusters_ = nClusters;
+	config_.maxDist_         = bsDist_ = maxDist;
+
+	initializeConfig();
+
+	frameTime_               = config_.ssSlotTime_ * config_.numberNodes_;
+
+	lstRndDelay_             = 0;
+
+	listenADV_               = true;
+	listenJOINREQ_           = false;
+}
+
+/* Initialize LEACH's configuration. */
+void LeachApp::initializeConfig()
+{
+	#define HDR_SIZE 25		// Originalmente era 25
+
+	config_.changeTimeIncrement_ = 10 * INITIAL_ENERGY;
+	config_.rndAdvDelay_         = TxTime(HDR_SIZE + 4); 
+	config_.ra_advTotal_         = 1 + config_.rndAdvDelay_ * (config_.desiredClusters_ * 4 + 1);
+	config_.ra_join_             = 0.01 * config_.numberNodes_;
+	config_.ra_delay_            = TxTime(HDR_SIZE + 4);
+	config_.spreading_           = config_.desiredClusters_ + 1;
+	config_.sigSize_             = 500; 
+	config_.ssSlotTime_          = TxTime(config_.sigSize_ + HDR_SIZE) * config_.spreading_;
+	config_.bsCode_              = 0;
+
+	#undef HDR_SIZE
+}
+
+LeachApp::~LeachApp()
+{
+	if (sensedData_ != NULL)
+		delete sensedData_;
+
+	delete eventHandler_;
+}
+
+void LeachApp::start()
+{
+	if (agent_ == NULL)
+	{
+		char agentName[32];
+
+		printf("Warning! LeachApp::start() => agent_ of %d is null! Creating a RCAgent!\n", sensor_node_->nodeid());
+
+		sprintf(agentName, "__rcagent%d", sensor_node_->nodeid());
+
+		agent_ = new RCAgent();
+		agent_->name(agentName);
+
+		Tcl::instance().enter(agent_);
+
+		printf("%s attach %s", name(), agent_->name());
+		Tcl::instance().evalf("%s attach %s", name(), agent_->name());
+	}
+
+	sensedData_->node_id() == sensor_node_->nodeid();
+
+	mac_ = (MacSensor *) ((RCAgent *) agent_)->getMAC();
+	mac_->node_num() = sensor_node_->nodeid();
+	decideClusterHead();
+
+	CommonNodeApp::start();
+}
+
+void LeachApp::goToSleep()
+{
+	((Battery *) sensor_node_->energy_model())->sleep();
+}
+
+void LeachApp::wakeUp()
+{
+	((Battery *) sensor_node_->energy_model())->wakeUp();
+}
+
+void LeachApp::setCode(int code)
+{
+	printf("%d is setting code to %d\n", sensor_node_->nodeid(), code);
+	code_        = code;
+	mac_->code() = code;
+}
+
+void LeachApp::setClusterHead()
+{
+	isCH_      = true;
+	hasBeenCH_ = true;
+	/* "... when a node decides to become a cluster-head,
+	 * it chooses randomly from a list of spreading codes."
+	 */
+}
+
+void LeachApp::unsetClusterHead()
+{
+	isCH_      = false;
+}
+
+/*** Distributed cluster set-up functions *****************/
+
+void LeachApp::decideClusterHead()
+{
+	int totRounds;
+
+	setCode(0);
+	wakeUp();
+
+	CHHeard_  = false;
+
+	// CheckIsAlive???
+
+	totRounds = config_.numberNodes_ / config_.desiredClusters_;
+
+	if (round_ >= totRounds)
+		round_ = 0;	
+
+	if (round_ == 0)
+		setHasNotBeenClusterHead();
+
+	if (Random::uniform(0, 1) < calculatePi())
+	{
+		printf("Node %d is a cluster head at time %lf\n", sensor_node_->nodeid(), Scheduler::instance().clock());
+
+		setClusterHead();
+
+		Scheduler::instance().schedule(
+			eventHandler_,
+			new LeachEvent(&LeachApp::advertiseClusterHead),
+			config_.rndAdvDelay_);
+	}
+	else
+	{
+		unsetClusterHead();
+		listenADV_ = true;
+		clearClusterChoices();
+	}
+
+	round_++;
+	nextChangeTime_ = Scheduler::instance().clock() + config_.changeTimeIncrement_;
+
+	Scheduler::instance().schedule(
+		eventHandler_,
+		new LeachEvent(&LeachApp::decideClusterHead),
+//		nextChangeTime_);
+		config_.changeTimeIncrement_);
+
+	Scheduler::instance().schedule(
+		eventHandler_,
+		new LeachEvent(&LeachApp::findBestCluster),
+		config_.ra_advTotal_);
+}
+
+double LeachApp::calculatePi()
+{
+	/*
+	 * Pi(t) = k / (N - k mod(r,N/k))
+	 * where k is the expected number of clusters per round
+	 * N is the total number of sensor nodes in the network
+	 * and r is the number of rounds that have already passed.
+	 */
+	register int n = config_.numberNodes_;
+	register int k = config_.desiredClusters_;
+	double thresh;
+
+	if (hasBeenClusterHead())
+		thresh = 0;
+
+	else if (n - k * round_ < 1)
+		thresh = 1;
+
+	else
+		thresh = (double) k / (n - k * round_);
+
+	return thresh;
+}
+
+void LeachApp::advertiseClusterHead()
+{
+	int clusterCode;
+	int numCodesAvail;
+
+	numCodesAvail = 2 * config_.spreading_ - 1;
+
+	
+	currentCH_ = sensor_node_->nodeid();
+	currentCHMAC_ = MAC_BROADCAST;
+
+	clusterCode = (mac_->myADVnum() % numCodesAvail) + 1;
+
+	setCode(clusterCode);
+
+	wakeUp();
+
+	send(
+		MAC_BROADCAST,
+		LINK_BROADCAST,
+		LEACH_ADV_CH,
+//		(char *) (&currentCH_),
+		(char *) (&code_),
+//		(char *) (&mac_->myADVnum()),
+		sizeof(currentCH_),
+		BYTES_ID,
+		config_.maxDist_,
+		0);
+
+	listenJOINREQ_ = true;
+
+	clusterNodes_.clear();
+}
+
+void LeachApp::findBestCluster()
+{
+//	int numCodesAvail, clusterCode;
+
+//	numCodesAvail = 2 * config_.spreading_ - 1;
+
+	if (isClusterHead())
+	{
+		// If node is CH, determine code and create a TDMA schedule.
+		dist_      = config_.maxDist_;
+		currentCH_ = sensor_node_->nodeid();
+		currentCHMAC_ = MAC_BROADCAST;
+//		myADVnum_  = mac_->myADVnum();
+
+		/* There are opt(spreading) - 1 codes available b/c need 1 code
+		 * for communication with the base station.
+		 */
+//		clusterCode   = (myADVnum_ % numCodesAvail) + 1;
+
+		Scheduler::instance().schedule(
+			eventHandler_,
+			new LeachEvent(&LeachApp::createSchedule),
+			config_.ra_advTotal_ + config_.ra_join_);
+	}
+	else
+	{
+		int clusterCode;
+
+		/* If node is not a CH, find the CH which allows minimum transmit
+		 * power for communication.  Set the code and "distance" parameters
+		 * accordingly.
+		 */
+		if (clusterChoices_.empty())
+		{
+			printf("Warning! No Cluster Head ADVs were heard by %d\n", sensor_node_->nodeid());
+			currentCH_ = -1;	// VER ISSO *****
+			currentCHMAC_ = MAC_BROADCAST;
+			sendMyDataToBS();
+			return;
+		}
+
+		double min_dist = config_.maxDist_ + 1;
+		int ind = 0;
+
+		for (CHs::iterator it = clusterChoices_.begin(); it != clusterChoices_.end(); it++, ind++)
+		{
+			chadv element = (chadv) *it;
+
+			if (element.distance < min_dist)
+			{
+				min_dist    = element.distance;
+				currentCH_  = element.nodeid;
+				currentCHMAC_ = element.mac;
+//				clusterCode = (ind % numCodesAvail) + 1;
+				clusterCode = element.code;
+			}
+		}
+
+		dist_ = min_dist;
+
+		printf("%d has choosen %d as cluster head (mac = %d)\n", sensor_node_->nodeid(), currentCH_, currentCHMAC_);
+
+		Scheduler::instance().schedule(
+			eventHandler_,
+			new LeachEvent(&LeachApp::informClusterHead),
+			config_.ra_advTotal_ + Random::uniform(0, config_.ra_join_ - config_.ra_delay_));;
+
+		goToSleep();
+	
+
+		setCode(clusterCode);
+		
+		printf("Current cluster-head of %d is %d, which code is %d, at distance is %lf\n",
+			sensor_node_->nodeid(),
+			currentCH_,
+			clusterCode,
+			dist_);
+	}
+
+	listenADV_ = false;
+	clearClusterChoices();
+}
+
+void LeachApp::informClusterHead()
+{
+	int dataSize;
+	int nodeId;
+
+	printf("%d sending JOIN_REQ to %d, distance = %lf , at time %lf\n",
+		sensor_node_->nodeid(),
+		currentCH_,
+		dist_,
+		Scheduler::instance().clock());
+
+	dataSize = config_.spreading_ * BYTES_ID;
+	nodeId   = sensor_node_->nodeid();
+
+	send(
+//		MAC_BROADCAST,
+		currentCHMAC_,
+		currentCH_,
+		LEACH_JOIN_REQ,
+		(char *) (&nodeId),
+		sizeof(int),
+		dataSize,
+		config_.maxDist_,		// Using maxDist_, the CH can discover node's distance
+//		dist_,
+		code_);
+}
+
+void LeachApp::createSchedule()
+{
+	if (clusterNodes_.empty())
+	{
+		printf("Warning! There are no nodes in cluster %d\n",
+			sensor_node_->nodeid());
+		sendMyDataToBS();
+	}
+	else
+	{
+		int * msg;
+		int i = 0;
+		int dataSize;
+
+		msg = new int[clusterNodes_.size()];
+
+		printf("%d sending TDMA schedule (ADV_SCH): ", sensor_node_->nodeid());
+
+		for (CNs::iterator it = clusterNodes_.begin(); it != clusterNodes_.end(); it++)
+		{
+			msg[i++] = (int) *it;
+			printf("%d ", (int) *it);
+		}
+
+		printf("at time %lf\n", Scheduler::instance().clock());
+
+		dataSize = config_.spreading_ * sizeof(int) * clusterNodes_.size();
+
+		tdmaSchedule_.assign(clusterNodes_.begin(), clusterNodes_.end());
+
+		send(
+			MAC_BROADCAST,
+//			sensor_node_->nodeid(),
+			LINK_BROADCAST,
+			LEACH_ADV_SCH,
+			(char *) msg,
+			sizeof(int) * clusterNodes_.size(),
+			dataSize,
+			dist_,
+			code_);
+
+		listenJOINREQ_ = false;
+
+//		delete [] msg;
+
+		frameTime_   = (5 + clusterNodes_.size()) * config_.ssSlotTime_;
+		lstRndDelay_ = Random::uniform(0, 0.01);
+		xmitTime_    = config_.ssSlotTime_ * (clusterNodes_.size()) + lstRndDelay_;
+
+		Scheduler::instance().schedule(
+			eventHandler_,
+			new LeachEvent(&LeachApp::sendDataToBS),
+			xmitTime_);
+	}
+}
+
+/*********************************************************/
+
+void LeachApp::recv(int type, double distance, int link_dst, int size, char * meta, int meta_size, int src_mac, int src_lnk)
+{
+#ifdef CHATO
+	printf("Receiving packet at %lf => ", Scheduler::instance().clock());
+#endif
+
+//	if (link_dst < 0) // || link_dst == sensor_node_->nodeid())
+		switch (type)
+		{
+			case LEACH_ADV_CH:
+#ifdef CHATO
+				printf("LEACH_ADV_CH\n");
+#endif
+//				if (isClusterHead())
+					recvADV_CH(meta, meta_size, distance, src_mac, src_lnk);
+				break;
+
+			case LEACH_JOIN_REQ:
+#ifdef CHATO
+				printf("JOIN_REQ\n");
+#endif
+
+//				if (sensor_node_->nodeid() == link_dst)
+					recvJOIN_REQ(meta, meta_size);
+				break;
+
+			case LEACH_ADV_SCH:
+#ifdef CHATO
+				printf("LEACH_ADV_SCH\n");
+#endif
+				recvADV_SCH(meta, meta_size, src_mac);
+				break;
+
+			case LEACH_DATA:
+#ifdef CHATO
+				printf("LEACH_DATA\n");
+#endif
+//				if (sensor_node_->nodeid() == link_dst)
+					recvData(meta, meta_size);
+				break;
+
+			case LEACH_BS_HELLO:
+#ifdef CHATO
+				printf("LEACH_BS_HELLO\n");
+#endif
+				recvBSHello(meta, meta_size, distance);
+				break;
+
+			default:
+				fprintf(stderr, "Unknown received data type on LeachApp!\n", type);
+				exit(-1);
+		}
+//	else
+//		fprintf(stderr, "Received a packet addressed to another node!\n");
+}
+
+void LeachApp::recvADV_CH(char * msg, int size, double distance, int src, int lnk_src)
+{
+	if (listenADV_)
+	{
+		chadv element;
+
+		if (!isClusterHead())
+			printf("%d received ADV_CH from %d (mac = %d, distance = %lf, code = %d) at %lf\n",
+				sensor_node_->nodeid(),
+				lnk_src,
+				src,
+				distance,
+				*((int *) msg),
+				Scheduler::instance().clock());
+
+		element.nodeid   = lnk_src;
+		element.distance = distance;
+		element.mac      = src;
+		element.code     = *((int *) msg);
+		element.object   = NULL;
+
+		clusterChoices_.push_back(element);
+	}
+}
+
+void LeachApp::recvJOIN_REQ(char * msg, int size)
+{
+	if (!isClusterHead())
+	{
+		fprintf(stderr, "Node %d received a JOIN_REQ from %d but it's not a cluster head!\n",
+			sensor_node_->nodeid(),
+			*((int *) msg));
+		exit(-1);
+	}
+
+	if (listenJOINREQ_)
+	{
+		printf("%d received JOIN_REQ from %d at %lf\n",
+			sensor_node_->nodeid(),
+			*((int *) msg),
+			Scheduler::instance().clock());
+
+		clusterNodes_.push_back(*((int *) msg));
+	}
+	else
+		printf("%d received a late JOIN_REQ from %d at %lf\n",
+			sensor_node_->nodeid(),
+			*((int *) msg),
+			Scheduler::instance().clock());
+}
+
+void LeachApp::recvADV_SCH(char * msg, int size, int src)
+{
+	int * vector = (int *) msg;
+	int elements = size / sizeof(int);
+	int nodeid   = sensor_node_->nodeid();
+	double xmitat;
+
+	if (src == currentCHMAC_)
+	{
+		printf("%d received ADV_SCH from %d at %lf\n",
+			sensor_node_->nodeid(),
+			src,
+			Scheduler::instance().clock());
+
+		for (int i = 0; i < elements; i++)
+			if (vector[i] == nodeid)
+			{
+				/* Determine time for a single TDMA frame. Each node sends data once
+				 * per frame in the specified slot.
+				 */
+				frameTime_  = (5 + elements) * config_.ssSlotTime_;
+				xmitTime_   = config_.ssSlotTime_ * i;
+				endFrmTime_ = frameTime_ - xmitTime_;
+				xmitat      = Scheduler::instance().clock() + xmitTime_;
+	
+				printf("Node %d schedule to transmit at %lf (%lf) | It is now %lf\n",
+					nodeid,
+					xmitat,
+					xmitTime_,
+					Scheduler::instance().clock());
+	
+				if (xmitat + endFrmTime_ < nextChangeTime_ - 10 * config_.ssSlotTime_)
+				{
+					Scheduler::instance().schedule(
+						eventHandler_,
+						new LeachEvent(&LeachApp::sendData),
+						xmitTime_);
+
+					goToSleep();
+				}
+				else
+					printf("teste!!!!!!!\n");
+				return;
+			}
+
+		// There is no time slot available
+		printf("Warning!!! %d doesn't have a transmit time for CH %d!\n", sensor_node_->nodeid(), currentCH_);
+	
+		sendMyDataToBS();
+	}
+}
+
+void LeachApp::recvData(char * msg, int size)
+{
+	printf("CH %d received data from %d at %lf",
+		sensor_node_->nodeid(),
+		((SensedData *) msg)->node_id(),
+		Scheduler::instance().clock());
+
+	mergeSensedData((SensedData *) msg);
+
+	printf(" - Now there is %d sensed data\n",
+		sensedData_->getData().size());
+}
+
+/* Occurs when received a base station "hello".
+ * This is usefull to determine the BS distance from
+ * node, but it is not original from LEACH paper.
+ * -- J�lio C�sar e Melo
+ */
+void LeachApp::recvBSHello(char * msg, int size, double distance)
+{
+	bsDist_ = distance;
+
+	printf("Node %d received BS_Hello at distance %lf\n",
+		sensor_node_->nodeid(),
+		distance);
+}
+
+/*********************************************************/
+
+void LeachApp::sendData()
+{
+	int    dataSize;
+	double xmitat;
+
+	if (sensedData_->count() > 0 && !isClusterHead())
+	{
+		dataSize = config_.spreading_ * (BYTES_ID * sensedData_->msgSize() + config_.sigSize_);
+
+		wakeUp();
+
+		printf("Node %d sending %d data to CH %d at %lf | d = %lf\n",
+			sensor_node_->nodeid(),
+			sensedData_->count(),
+			currentCH_,
+			Scheduler::instance().clock() + frameTime_,
+			dist_);
+
+		sensedData_->node_id() = sensor_node_->nodeid();
+
+		send(
+	//		MAC_BROADCAST,
+			currentCHMAC_,
+			currentCH_,
+			LEACH_DATA,
+			sensedData_,
+			dataSize,
+			dist_,
+			code_);
+
+		// sensedData_ = new SensedData();
+		clearSensedData();
+
+		if (!isClusterHead())
+			goToSleep();
+	}
+
+	xmitat = Scheduler::instance().clock() + frameTime_;
+
+	if (xmitat + endFrmTime_ < nextChangeTime_ - 10 * config_.ssSlotTime_)
+		Scheduler::instance().schedule(
+			eventHandler_,
+			new LeachEvent(&LeachApp::sendData),
+			frameTime_);
+}
+
+void LeachApp::send(int mac_dst, int link_dst, int type, char * msg, int msg_size, int data_size, double dist, int code)
+{
+	if (dist <= 0)
+	{
+		printf("Distancia invalida! %lf\n", dist);
+		exit(-1);
+	}
+
+	((RCAgent *) agent_)->sendmsg(
+		data_size,
+		msg,
+		msg_size,
+		mac_dst,
+		link_dst,
+		dist,
+		code,
+		type);
+}
+
+void LeachApp::send(int mac_dst, int link_dst, int type, void * msg, int msg_size, int data_size, double dist, int code)
+{
+	send(
+		mac_dst,
+		link_dst,
+		type,
+		(char *) msg,
+		msg_size,
+		data_size,
+		dist,
+		code);
+}
+
+void LeachApp::send(int mac_dst, int link_dst, int type, SensedData * msg, int data_size, double dist, int code)
+{
+	send(
+		mac_dst,
+		link_dst,
+		type,
+		(char *) msg,
+		msg->msgSize(),
+		data_size,
+		dist,
+		code);
+}
+
+void LeachApp::sendDataToBS()
+{
+	int    dataSize, compressedSize;
+	double dist;
+	double xmitat;
+	double rndDelay;
+
+	rndDelay     = Random::uniform(0, 0.01);
+	xmitat       = rndDelay - lstRndDelay_ + frameTime_;
+	lstRndDelay_ = rndDelay;
+
+	if (sensedData_->count() > 0)
+	{
+		dataSize       = config_.spreading_ * (BYTES_ID * sensedData_->msgSize() + config_.sigSize_);
+
+		if (!isClusterHead())
+			wakeUp();
+
+		printf("Node %d sending %d data to BS at time %lf\n",
+			sensor_node_->nodeid(),
+			sensedData_->count(),
+			Scheduler::instance().clock());
+
+		sensedData_->timeStamp() = Scheduler::instance().clock();
+		sensedData_->node_id() = sensor_node_->nodeid();
+
+		send(
+			MAC_BROADCAST,
+			destination_id_,
+			LEACH_DATA,
+			sensedData_,
+			dataSize,
+			bsDist_,
+			config_.bsCode_);
+
+		if (!isClusterHead())
+			goToSleep();
+
+		clearSensedData();
+	}
+	
+	if (xmitat + endFrmTime_ < nextChangeTime_ - 10 * config_.ssSlotTime_)
+		Scheduler::instance().schedule(
+			eventHandler_,
+			new LeachEvent(&LeachApp::sendDataToBS),
+			xmitat);
+}
+
+void LeachApp::sendMyDataToBS()
+{
+	sendDataToBS();
+}
+
+void LeachApp::disseminateData(SensedData * data)
+{                                                                                                                            
+	if (data != NULL)
+	{
+		printf("Common Node %d - Disseminating data -  Time %.3lf\n",
+                        sensor_node_->nodeid(),Scheduler::instance().clock());
+
+//		printf("%d is aggregating sensed data -  Time %.3lf",
+//			sensor_node_->nodeid(),Scheduler::instance().clock());
+
+		mergeSensedData(data);
+
+		printf(" - There is %d data aggregated.\n", sensedData_->count()); //sensedData_->getData().size());
+	}
+}
+
+void LeachApp::mergeSensedData(SensedData * data)
+{
+	AppDataList list;
+
+	list = data->getData();
+
+	for (AppDataList::iterator it = list.begin(); it != list.end(); it++)
+		sensedData_->insertNewData(*it);
+}
+
+void LeachApp::clearClusterChoices()
+{
+	for (CHs::iterator it = clusterChoices_.begin(); it != clusterChoices_.end(); it++)
+	{
+		chadv element = (chadv) *it;
+		
+		if (element.object != NULL)
+			delete element.object;
+	}
+	
+	clusterChoices_.clear();
+}
+
+void LeachApp::clearSensedData()
+{
+	sensedData_->clear();
+}
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/app/leachApp.h ns-allinone-2.35/ns-2.35/mannasim/leach/app/leachApp.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/app/leachApp.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/app/leachApp.h	2009-11-12 15:43:37.000000000 +0100
@@ -0,0 +1,204 @@
+#ifndef _LEACHAPP_H_
+#define _LEACHAPP_H_
+
+#include <mannasim/sensorBaseApp.h>
+#include <mannasim/sensedData.h>
+#include <scheduler.h>
+#include <list>
+#include <mannasim/leach/mac/mac-sensor.h>
+
+#define LEACH_ADV_CH           0
+#define LEACH_JOIN_REQ         1
+#define LEACH_ADV_SCH          2
+#define LEACH_DATA             3
+#define LEACH_BS_HELLO         4	/* Base station sends a "hello"
+					 * to sensor nodes discover its distance.
+					 * -- J�lio C�sar e Melo
+					 */
+
+#define BYTES_ID	 sizeof(int)
+
+#define LINK_BROADCAST        -1
+
+#define INITIAL_ENERGY 10
+//#include <list>
+
+//using namespace std;
+
+#include <mannasim/commonNodeApp.h>
+
+class LeachApp : public CommonNodeApp //SensorBaseApp
+{
+	protected:
+		class LeachEvent : public Event
+		{
+			public:
+				typedef void (LeachApp::*delegation) (void);
+
+			private:
+				delegation delegate_;
+
+			public:
+				LeachEvent(delegation delegate)
+				{
+					this->delegate_ = delegate;
+				}
+
+				delegation getDelegate() { return delegate_; }
+				void setDelegate(delegation delegate) { delegate_ = delegate; }
+
+				inline void executeDelegation(LeachApp * app)
+				{
+					(app->*delegate_)();
+				}
+		};
+
+		class LeachEventHandler : public Handler
+		{
+			private:
+				LeachApp * app_;
+			public:
+				LeachEventHandler(LeachApp * app) { app_ = app; }
+
+				void handle(Event * event)
+				{
+					LeachEvent * levent = (LeachEvent *) event;
+
+					levent->executeDelegation(app_);
+				}
+		};
+
+	public:
+		struct chadv
+		{
+			int    nodeid;
+			int    mac;
+			double distance;
+			int    code;
+			void * object;
+		};
+
+		typedef list <chadv> CHs;
+		typedef list <int>   CNs;
+
+	protected:
+		LeachEventHandler     * eventHandler_;
+
+		// List of cluster heads
+		CHs                     clusterChoices_;
+
+		// List of cluster nodes
+		CNs			clusterNodes_;
+		CNs			tdmaSchedule_;
+
+		// Sensed data
+		SensedData            * sensedData_;
+
+	protected:
+		MacSensor * mac_;
+		double      nextChangeTime_;
+	
+	private:
+		bool        isCH_;	        // Is cluster-head?
+		bool        hasBeenCH_;      // Has been cluster-head?
+
+	public:
+		struct leachConfig
+		{
+			int         numberNodes_;		// opt(nn)
+			int         desiredClusters_;		// opt(num_clusters)
+			double	    changeTimeIncrement_;	// opt(ch_change)
+			double      rndAdvDelay_;		// opt(ra_adv)
+			double      ra_advTotal_;		// opt(ra_adv_total)
+			double      ra_join_;			// opt(ra_join)
+			double      ra_delay_;			// opt(ra_delay);
+			double      maxDist_;			// opt(max_dist)
+			int         spreading_;			// opt(spreading)
+			double      ssSlotTime_;		// opt(ss_slot_time)
+			int         sigSize_;			// opt(sig_size)	Bytes for data signal
+			int         bsCode_;			// opt(bsCode)
+		};
+
+	protected:
+		leachConfig config_;
+		int         round_;
+		double      dist_;
+		double      bsDist_;
+		int         code_;
+		double      now_;
+		double      frameTime_;
+		double      endFrmTime_;
+		double      beginIdle_;
+		double      beginSleep_;
+		int         myADVnum_;
+		bool        CHHeard_;
+		double      xmitTime_;
+		double      lstRndDelay_;		// Last random delay
+		int         currentCH_;
+		int         currentCHMAC_;
+		bool        listenADV_;			// If it's listenning to ADV
+		bool        listenJOINREQ_;		// If it's listenning to JOIN_REQ
+		
+	public:
+		LeachApp(int nNodes, int nClusters, double maxDist);
+		~LeachApp();
+
+		void start();
+
+		void goToSleep();
+		void wakeUp();
+
+		// checkAlive not implemented!
+
+		bool isClusterHead() { return isCH_; }
+		bool hasBeenClusterHead() { return hasBeenCH_; }
+		void setHasNotBeenClusterHead() { hasBeenCH_ = 0; }
+		void setClusterHead();
+		void unsetClusterHead();
+
+		virtual void findBestCluster();
+		virtual void informClusterHead();
+		virtual void createSchedule();
+		virtual void advertiseClusterHead();
+
+		void recv(int type, double distance, int link_dst, int size, char * meta, int meta_size, int src_mac, int src_lnk);
+		virtual void sendData();
+		virtual void sendDataToBS();
+		void sendMyDataToBS();
+
+	protected:
+		virtual void decideClusterHead();
+
+		// Probability to turn cluster head
+		virtual double calculatePi();
+
+		virtual void recvADV_CH(char *, int, double, int, int);
+		inline void recvJOIN_REQ(char *, int);
+		inline void recvADV_SCH(char *, int, int);
+		inline void recvData(char *, int);
+		inline void recvBSHello(char *, int, double);
+
+		inline void send(int mac_dst, int link_dst, int type, char * msg, int msg_size, int data_size, double dist, int code);
+		inline void send(int mac_dst, int link_dst, int type, void * msg, int msg_size, int data_size, double dist, int code);
+		inline void send(int mac_dst, int link_dst, int type, SensedData * msg, int data_size, double dist, int code);
+        virtual void disseminateData(SensedData * data);
+
+		/* Calculate time required to transmit n bytes of data,
+		 * considering a 1 Mbps radio speed.
+		 */
+		virtual double TxTime(int n) { return n * 8.0 / 1000000.0; }
+
+		/* Initialize LEACH's configuration */
+		virtual void initializeConfig();
+
+	protected:
+		void setCode(int code);
+	
+	protected:
+		virtual void mergeSensedData(SensedData *);
+		void clearClusterChoices();
+		virtual void clearSensedData();
+		int calculateCompression(SensedData * sensedData);
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/app/leachData.h ns-allinone-2.35/ns-2.35/mannasim/leach/app/leachData.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/app/leachData.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/app/leachData.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,15 @@
+#include <ns-process.h>
+
+class LeachAdvCHData : public AppData
+{
+	private:
+		int nodeid_;
+
+	public:
+		LeachAdvCHData(int nodeid) : AppData(LEACH_ADV_CH)
+		{
+			this->nodeid_ = nodeid;
+		}
+
+		inline int & nodeid() { return nodeid_; }
+};
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/leachAgent.cc ns-allinone-2.35/ns-2.35/mannasim/leach/leachAgent.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/leachAgent.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/leachAgent.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,46 @@
+#include <mannasim/accessPointApp.h>
+#include "leachAgent.h"
+
+static class LeachAgentClass : public TclClass
+{
+	public:
+		LeachAgentClass() : TclClass("Agent/RCAgent/LeachAgent") {}
+
+		TclObject* create(int, const char*const*)
+		{
+			return (new LeachAgent());
+		}
+} class_leach_agent;
+
+
+void LeachAgent::recv(Packet* p, Handler*)
+{
+	hdr_cmn *hdr = HDR_CMN(p);
+	hdr_rca *rca_hdr = HDR_RCA(p);
+
+//	if (app_ && (rca_hdr->rca_link_dst() < 0 || rca_hdr->rca_link_dst() == ((AcessPointApp *) app_)->sensor_node()->nodeid()))
+
+	packetMsg_ = rca_hdr->msg_type();
+	distEst_ = rca_hdr->dist_est();
+
+	if (packetMsg_ == LEACH_DATA)
+	{
+// DEBUG
+//		printf("|Access point received at %lf, packet = %d, distance = %lf, packet_msg = %d, meta = %d\n, meta_size = %d\n",
+//			Scheduler::instance().clock(),
+//			p,
+//			distEst_,
+//			packetMsg_,
+//			rca_hdr->meta(),
+//			rca_hdr->meta_size());
+//			
+//		printf("=) %d %d\n", rca_hdr->rca_link_src(), rca_hdr->meta());
+		((AccessPointApp *) app_)->process_data(rca_hdr->meta_size(), (AppData *) rca_hdr->meta());
+	}
+
+//	((AccessPointApp *) app_)->recv(packetMsg_, distEst_, rca_hdr->rca_link_dst(), hdr->size(), rca_hdr->meta(),
+//               rca_hdr->meta_size(), rca_hdr->rca_mac_src(), rca_hdr->rca_link_src());
+
+	Packet::free(p);
+}
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/leachAgent.h ns-allinone-2.35/ns-2.35/mannasim/leach/leachAgent.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/leachAgent.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/leachAgent.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,16 @@
+#ifndef _LEACH_AGENT_H_
+#define _LEACH_AGENT_H_
+
+#include <mannasim/leach/app/leachApp.h>
+#include <mannasim/leach/rca/rcagent.h>
+
+class LeachAgent : public RCAgent
+{
+	public:
+		virtual void recv(Packet*, Handler*);
+};
+
+#endif
+
+
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/mac/leach-wireless-phy.cc ns-allinone-2.35/ns-2.35/mannasim/leach/mac/leach-wireless-phy.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/mac/leach-wireless-phy.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/mac/leach-wireless-phy.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,173 @@
+#include "leach-wireless-phy.h"
+
+static class LeachWirelessPhyClass : public TclClass
+{
+	public:
+		LeachWirelessPhyClass() : TclClass("Phy/WirelessPhy/LeachWirelessPhy") {}
+
+		TclObject* create(int, const char * const *)
+		{
+			return new LeachWirelessPhy();
+		}
+} class_LeachWirelessPhy;
+
+/*****************************************************************************/
+
+LeachWirelessPhy::LeachWirelessPhy()
+{
+	cs_end_ = new double[CS_MAX_CODE + 1];
+
+	for (int i = 0; i < CS_MAX_CODE + 1; i++)
+		cs_end_[i] = 0;
+
+        bandwidth_ = 1000000;                // 100 Mbps
+        Efriss_amp_ = 100 * 1e-12;           // Friss amp energy (J/bit/m^2)
+        Etwo_ray_amp_ = 0.013 * 1e-12;       // Two-ray amp energy (J/bit/m^4)
+        EXcvr_ = 50 * 1e-9;                  // Xcvr energy (J/bit)	
+        // Use this base threshold to get a "hearing radius" of ~ 1 m
+	//         //   Pfriss_amp_ = Efriss_amp_ * bandwidth_;      // Friss power (W/m^2)
+        Ptwo_ray_amp_ = Etwo_ray_amp_ * bandwidth_;  // Two-ray power (W/m^4)
+        PXcvr_ = EXcvr_ * bandwidth_;        // Xcvr power (W)
+        ss_ = 1;                             // amount of spreading
+//        time_finish_rcv_ = 0;
+        dist_ = 0;                           // approx. distance to transmitter
+}
+
+LeachWirelessPhy::~LeachWirelessPhy()
+{
+	delete [] cs_end_;
+}
+
+int LeachWirelessPhy::sendUp(Packet *p)
+{
+	double Pr;
+	int pk_recvd = 0;
+	PacketStamp s;
+
+	if(propagation_)
+	{
+                s.stamp((MobileNode*)node(), ant_, 0, lambda_);
+                Pr = propagation_->Pr(&p->txinfo_, &s, this);
+	}
+
+	hdr_cmn *ch = HDR_CMN(p);
+	hdr_rca *rca_hdr = HDR_RCA(p);
+
+	// Record when this packet ends and its code.
+	int code = rca_hdr->get_code();
+
+//	printf("Tempo de recebimento para pacote: %lf\n", txtime(p));
+	cs_end_[code] = Scheduler::instance().clock() + txtime(p);
+
+	pk_recvd = WirelessPhy::sendUp(p);
+
+	if (pk_recvd)
+	{	
+		/*
+		** Determine approximate distance of node transmitting node
+		** from received power.
+		**/
+		double hr, ht;        // height of recv and xmit antennas
+		double rX, rY, rZ;    // receiver location
+		double d1, d2;
+		double crossover_dist, Pt, M;
+
+		((MobileNode *) node_)->getLoc(&rX, &rY, &rZ);
+
+		hr = rZ + ant_->getZ();
+		ht = hr;              // assume transmitting node antenna at same height
+
+		crossover_dist = sqrt((16 * PI * PI * L_ * ht * ht * hr * hr)
+				/ (lambda_ * lambda_));
+
+		Pt = p->txinfo_.getTxPr();
+		M = lambda_ / (4 * PI);
+		d1 = sqrt( (Pt * M * M) / (L_ * Pr) );
+		d2 = sqrt(sqrt( (Pt * hr * hr * ht * ht) / Pr) );
+
+		if (d1 < crossover_dist)
+			dist_ = d1;
+		else
+			dist_ = d2;
+
+		rca_hdr->dist_est() = (int) ceil(dist_);
+	}
+
+	return pk_recvd;
+}
+
+void LeachWirelessPhy::sendDown(Packet * p)
+{
+	if ((node()->energy_model()->node_on() != true) || (node()->energy_model()->sleep()))
+	{
+		printf("Node is not on or it is sleeping!\n");
+		return;
+	}
+
+	/*
+	** The power for transmission depends on the distance between
+	** the transmitter and the receiver.  If this distance is
+	** less than the crossover distance:
+	**       (c_d)^2 =  16 * PI^2 * L * hr^2 * ht^2
+	**               ---------------------------------
+	**                           lambda^2
+	** the power falls off using the Friss equation.  Otherwise, the
+	** power falls off using the two-ray ground reflection model.
+	** Therefore, the power for transmission of a bit is:
+	**      Pt = Pfriss_amp_*d^2 if d < c_d
+	**      Pt = Ptwo_ray_amp_*d^4 if d >= c_d.
+	** The total power dissipated per bit is PXcvr_ + Pt.
+	**/
+	hdr_cmn *ch = HDR_CMN(p);
+	hdr_rca *rca_hdr = HDR_RCA(p);
+
+	double d = rca_hdr->get_dist();
+        double hr, ht;        // height of recv and xmit antennas
+	double tX, tY, tZ;    // transmitter location
+
+	((MobileNode *) node_)->getLoc(&tX, &tY, &tZ);
+
+	ht = tZ + ant_->getZ();
+	hr = ht;              // assume receiving node and antenna at same height
+
+	double crossover_dist = sqrt((16 * PI * PI * L_ * ht * ht * hr * hr)
+	                                           / (lambda_ * lambda_));
+
+	if (d < crossover_dist)
+		if (d > 1)
+			Pt_ = Efriss_amp_ * bandwidth_ * d * d;
+          	else
+			// Pfriss_amp_ is the minimum transmit amplifier power.
+	                Pt_ = Efriss_amp_ * bandwidth_;
+        else
+		Pt_ = Etwo_ray_amp_ * bandwidth_ * d * d * d * d;
+
+	PXcvr_ = EXcvr_ * bandwidth_;
+
+	// if (energy_->remove(pktEnergy(Pt_, PXcvr_, ch->size())) != 0)
+	//	alive_ = 0;
+
+	Pt_consume_ = pktEnergy(Pt_, PXcvr_, ch->size());
+
+	WirelessPhy::sendDown(p);
+}
+
+double LeachWirelessPhy::pktEnergy(double pt, double pxcvr, int nbytes)
+{
+	/*
+	** Energy (in Joules) is power (in Watts=Joules/sec) divided by
+	** bandwidth (in bits/sec) multiplied by the number of bytes, times 8 bits.
+	**/
+	// If data has been spread, power per DATA bit should be the same
+	// as if there was no spreading ==> divide transmit power
+	// by spreading factor.
+
+	double bits = (double) nbytes * 8;
+
+	pt /= ss_;
+
+	double j = bits * (pt + pxcvr) / bandwidth_;
+
+	return j;
+}
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/mac/leach-wireless-phy.h ns-allinone-2.35/ns-2.35/mannasim/leach/mac/leach-wireless-phy.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/mac/leach-wireless-phy.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/mac/leach-wireless-phy.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,40 @@
+#include <wireless-phy.h>
+
+#define CS_MAX_CODE          999
+
+class LeachWirelessPhy : public WirelessPhy
+{
+	private:
+		double pktEnergy(double pt, double pxcvr, int nbytes);
+
+	protected:
+		double *cs_end_;                     // time when carrier sence will end per code
+
+	        double Efriss_amp_;                  // Xmit amp energy (J/bit/m^2)
+	        double Etwo_ray_amp_;                // Xmit amp energy (J/bit/m^4)
+	        double EXcvr_;                       // Xcvr energy (J/bit)
+	        double Pfriss_amp_;                  // Friss base transmission power (W/m^2)
+	        double Ptwo_ray_amp_;                // Two-ray base transmission power (W/m^4)
+	        double PXcvr_;                       // Xcvr Power (W)
+		double dist_;                        // approx. distance to transmitter
+		int ss_;                             // amount of spreading
+
+
+	public:
+		LeachWirelessPhy();
+		~LeachWirelessPhy();
+
+		inline double csEnd(int code)
+		{
+			if (code > CS_MAX_CODE || code < 0)
+			{
+				fprintf(stderr, "csEnd(code): code > CS_MAX_CODE?; %d %d\n", code, CS_MAX_CODE);
+				exit(-1);
+			}
+
+			return cs_end_[code];
+		}
+
+		int sendUp(Packet * p);
+		void sendDown(Packet * p);
+};
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/mac/mac-sensor.cc ns-allinone-2.35/ns-2.35/mannasim/leach/mac/mac-sensor.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/mac/mac-sensor.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/mac/mac-sensor.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,383 @@
+/******************************************************************
+ * This code was developed as part of the MIT uAMPS project.      *
+ ******************************************************************/
+
+#include "mac-sensor.h"
+#include "leach-wireless-phy.h"
+
+
+/* ======================================================================
+   Macros
+   ====================================================================== */
+
+#define SET_RX_STATE(x)                \
+{                                      \
+  rx_state_ = (x);                    \
+}
+
+#define SET_TX_STATE(x)                \
+{                                      \
+  tx_state_ = (x);                    \
+}
+
+
+/* ======================================================================
+   TCL Hooks for the simulator
+   ====================================================================== */
+static class MacSensorClass : public TclClass {
+public:
+  MacSensorClass() : TclClass("Mac/Sensor") {}
+  TclObject* create(int, const char*const*) {
+    return (new MacSensor());
+  }
+} class_macSensor;
+
+
+/* ======================================================================
+   Mac Class Functions
+   ====================================================================== */
+MacSensor::MacSensor() : Mac(), mhDefer_(this, 0.005), mhTx_(this), 
+  mhRx_(this), code_(0), ss_(10), CHheard_(0),
+  myADVnum_(0)
+{
+
+  tx_state_ = rx_state_ = MAC_IDLE;
+
+  sta_seqno_ = 1;
+  cache_ = 0;
+  cache_node_count_ = 0;
+
+/*  bind("code_",&code_);
+//  bind("base_X",&base_X);
+//  bind("base_Y",&base_Y);
+  bind("node_num_",&node_num_);
+  bind("ss_",&ss_);
+  bind("CHheard_",&CHheard_);
+  bind("myADVnum_",&myADVnum_);
+*/
+}
+
+int
+MacSensor::command(int argc, const char*const* argv)
+{
+  if (argc == 3) {
+
+    if (strcmp(argv[1], "log-target") == 0) {
+      logtarget_ = (NsObject*) TclObject::lookup(argv[2]);
+      if(logtarget_ == 0)
+        return TCL_ERROR;
+      return TCL_OK;
+    }
+
+    if(strcmp(argv[1], "nodes") == 0) {
+      if(cache_) return TCL_ERROR;
+      cache_node_count_ = atoi(argv[2]) + 1;
+      cache_ = new Host[cache_node_count_ + 1];
+      assert(cache_);
+      bzero(cache_, sizeof(Host) * (cache_node_count_+1 ));
+      return TCL_OK;
+      
+    }
+  }
+  return Mac::command(argc, argv);
+}
+
+/* ======================================================================
+   Misc Routines
+   ====================================================================== */
+
+inline int
+MacSensor::is_idle()
+{
+  if(rx_state_ != MAC_IDLE)
+    return 0;
+
+  if(tx_state_ != MAC_IDLE)
+    return 0;
+
+  return 1;
+}
+
+/* ======================================================================
+   Outgoing Packet Routines
+   ====================================================================== */
+
+void
+MacSensor::send(Packet *p, Handler *h)
+{
+  struct hdr_macSensor* dh = HDR_MACSensor(p);
+
+  if (h != 0)
+    callback_ = h;
+
+  hdr_rca *rca_hdr = HDR_RCA(p);
+  int code = rca_hdr->get_code();
+
+  /* 
+   * Perform carrier sence.  If the channel is busy, backoff. 
+   */
+  if(!is_idle() || ((LeachWirelessPhy *) netif_)->csEnd(code) > Scheduler::instance().clock()) {
+    /*
+    printf("CSMA: Node %d defering %s for time %f: code = %d ...\n", 
+            rca_hdr->rca_src(),rca_hdr->meta(),TX_Time(p),code);
+    fflush(stdout);
+    */
+    //mhDefer_.start(p, Random::uniform(TX_Time(p)));
+    mhDefer_.start(p, TX_Time(p));
+    return;
+  }
+
+  pktTx_ = p;
+
+  /*
+   * Determine how many ADV messages have been heard to determine
+   * spreading code to use for each cluster.
+   */
+  myADVnum_ = CHheard_;
+
+  hdr_cmn::access(p)->txtime() = TX_Time(p);
+
+  /*
+   * Assign the data packet a sequence number.
+   */
+  dh->dh_scontrol = sta_seqno_++;
+
+  SET_TX_STATE(MAC_SEND);              
+  /* 
+   * Start a timer that expires when the packet transmission is complete.
+   */
+  mhTx_.start(p->copy(), TX_Time(p));
+  downtarget_->recv(pktTx_, this);        
+  /*
+  struct hdr_mac *mh = HDR_MAC(pktTx_);
+  printf("%d sending data to %d at time %f\n", mh->macSA(), mh->macDA(),
+  Scheduler::instance().clock());
+  fflush(stdout);
+  */
+
+  if(callback_) {
+    Handler *h = callback_;
+    callback_ = 0;
+    h->handle((Event*) 0);
+  } 
+
+}
+
+/* ======================================================================
+   Incoming Packet Routines
+   ====================================================================== */
+
+void
+MacSensor::recv(Packet *p, Handler *h)
+{
+  struct hdr_cmn *hdr = HDR_CMN(p);
+
+  /*
+   * Sanity Check
+   */
+  assert(initialized());
+
+  /*
+   * Handle outgoing packets.
+   */
+  if(hdr->direction() == -1) {
+
+    /*
+      * Update the MAC header
+      */
+    hdr->size() += ETHER_HDR_LEN;
+    send(p, h);
+    return;
+  }
+
+  /*
+   * Handle incoming packets.
+   * We just received the 1st bit of a packet on the interface.
+   */
+
+  hdr_rca *rca_hdr = HDR_RCA(p);
+  if (rca_hdr->msg_type() == ADV_TYPE) 
+    CHheard_++;
+
+  /*
+   * If I am not receiving the code of the incoming packet, drop it.
+   */
+  int new_code = rca_hdr->get_code();
+  if (new_code != code_) {
+      
+//      printf("In MAC_IDLE %d: %d is not a code I am currently receiving %d.\n", node_num_, new_code, code_);
+//      fflush(stdout);
+      
+        Packet::free(p);
+      return;
+  }
+
+  /*
+   *  If the interface is currently in transmit mode, then
+   *  it probably won't even see this packet.  However, the
+   *  "air" around me is BUSY so I need to let the packet
+   *  proceed.  Just set the error flag in the common header
+   *  so that the packet gets thrown away.
+   */
+  if(tx_state_ && hdr->error() == 0) {
+    printf("Warning! %d: Cannot receive while transmitting.\n", node_num_);
+    fflush(stdout);
+    hdr->error() = 1;
+  }
+
+  /* 
+   * If more than ss_ simultaneous transmissions occur, there is a
+   * collision and I cannot receive the packet.
+   */ 
+  int num_codes = 0;
+  for (int i = 0; i < 1000; i++) 
+    if (((LeachWirelessPhy *) netif_)->csEnd(i) > Scheduler::instance().clock()) 
+      num_codes++;
+  if (num_codes > ss_) {
+    printf("I can hear %d different packets ==> collision.\n", num_codes);
+    fflush(stdout);
+    collision(p);
+    return;
+  }
+
+  if(rx_state_ == MAC_IDLE) {
+
+    SET_RX_STATE(MAC_RECV);
+
+    pktRx_ = p;
+
+    /*
+     * Schedule the reception of this packet, in txtime seconds.
+     */
+    double rtime = TX_Time(p);
+    assert(rtime >= 0.0);
+    mhRx_.start(p, rtime);
+  }
+  else {
+    /*
+     *  If the power of the incoming packet is smaller than the
+     *  power of the packet currently being received by at least
+     *  the capture threshold, then we ignore the new packet.
+     */
+  
+    if(hdr->error() == 0) {
+      hdr->error() = 1;
+    }
+     if(pktRx_->txinfo_.RxPr / p->txinfo_.RxPr >= p->txinfo_.CPThresh) {
+        capture(p);
+     } else {
+      collision(p);
+     }
+  }
+}
+
+void
+MacSensor::capture(Packet *p)
+{
+  printf("CAPTURE!!!!\n");
+  fflush(stdout);
+  Packet::free(p);
+  //p = 0;
+}
+
+void
+MacSensor::collision(Packet *p)
+{
+  printf("COLLISION!!!!\n");
+  fflush(stdout);
+  switch(rx_state_) {
+
+  case MAC_RECV:
+    SET_RX_STATE(MAC_COLL);
+
+    /* fall through */
+
+  case MAC_COLL:
+    assert(pktRx_);
+    assert(mhRecv_.busy);
+
+    /*
+     *  Since a collision has occurred, figure out
+     *  which packet that caused the collision will
+     *  "last" the longest.  Make this packet,
+     *  pktRx_ and reset the Recv Timer if necessary.
+     */
+    if(TX_Time(p) > mhRx_.expire()) {
+      mhRx_.stop(pktRx_);
+      Packet::free(pktRx_);
+      pktRx_ = p;
+      mhRx_.start(pktRx_,TX_Time(pktRx_));
+    }
+    else {
+      Packet::free(p);
+    }
+    break;
+
+  default:
+    assert(0);
+  }
+}
+
+void
+MacSensor::recvDATA(Packet *p)
+{
+  /*
+   * Adjust the MAC packet size - ie, strip off the mac header.
+   */
+  struct hdr_cmn *ch = HDR_CMN(p);
+  ch->size() -= ETHER_HDR_LEN;
+  ch->num_forwards() += 1;
+
+  /*
+   *  Pass the packet up to the link-layer.
+   */
+  uptarget_->recv(p, (Handler*) 0);
+}
+
+void
+MacSensor::deferHandler(Event *e)
+{
+  /*
+  hdr_rca *rca_hdr = HDR_RCA((Packet *)e);
+  printf("Node %d trying to send %s again at time %f.\n", node_num_, 
+          rca_hdr->meta(), Scheduler::instance().clock());
+  fflush(stdout);
+  */
+  /*
+   * After timer expires, try to transmit the packet (i.e., perform
+   * carrier sense again to see if the channel is now free).
+   */
+  send((Packet *)e,(Handler*) 0);
+}
+
+void
+MacSensor::recvHandler(Event *e)
+{
+
+  if (rx_state_ == MAC_COLL) {
+    struct hdr_cmn *ch = HDR_CMN(pktRx_);
+    ch->error() = 1;
+  }
+  SET_RX_STATE(MAC_IDLE);
+
+  /*
+   * If this packet was unicast and not intended for me, drop it.
+   */   
+  struct hdr_mac *mh = HDR_MAC(pktRx_);
+  int dst = mh->macDA();
+
+  if (dst != index_ && (u_int32_t) dst != (u_int32_t) MAC_BROADCAST) 
+      Packet::free(pktRx_);
+  else 
+    recvDATA(pktRx_);
+}
+
+void
+MacSensor::sendHandler(Event *e)
+{
+  /* 
+   * Once transmission is complete, drop the packet.
+   */
+  SET_TX_STATE(MAC_IDLE);
+  Packet::free((Packet *)e);
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/mac/mac-sensor.h ns-allinone-2.35/ns-2.35/mannasim/leach/mac/mac-sensor.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/mac/mac-sensor.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/mac/mac-sensor.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,145 @@
+/******************************************************************
+ * This code was developed as part of the MIT uAMPS project.      *
+ ******************************************************************/
+
+#ifndef ns_mac_sensor_h
+#define ns_mac_sensor_h
+
+#include "mac.h"
+#include "mac-sensor-timers.h"
+#include "random.h"
+
+#define GET_ETHER_TYPE(x)		GET2BYTE((x))
+#define SET_ETHER_TYPE(x,y) {u_int16_t t = (y); STORE2BYTE(x,&t);}
+
+#define ADV_TYPE 0
+
+/* ======================================================================
+   Frame Formats
+   ====================================================================== */
+
+struct hdr_macSensor {
+	u_int16_t		dh_duration;
+	u_char			dh_da[ETHER_ADDR_LEN];
+	u_char			dh_sa[ETHER_ADDR_LEN];
+	u_int16_t		dh_scontrol;
+};
+
+
+/* ======================================================================
+   Definitions
+   ====================================================================== */
+
+#define ETHER_HDR_LEN				\
+	(sizeof(struct hdr_macSensor) +		\
+	 ETHER_FCS_LEN)
+
+#define DATA_Time(len)	(8 * (len) / bandwidth_)
+
+
+/* ======================================================================
+   The following destination class is used for duplicate detection.
+   ====================================================================== */
+
+class Host {
+public:
+	LIST_ENTRY(Host) link;
+	u_int32_t	index;
+	u_int32_t	seqno;
+};
+
+
+/* ======================================================================
+   The actual Sensor MAC class.
+   ====================================================================== */
+
+class MacSensor : public Mac {
+
+	friend class DeferSensorTimer;
+	friend class TxSensorTimer;
+	friend class RxSensorTimer;
+
+public:
+	MacSensor();
+	void		recv(Packet *p, Handler *h);
+
+private:
+	int		command(int argc, const char*const* argv);
+
+	/*
+	 * Packet Transmission Functions.
+	 */
+	void		send(Packet *p, Handler *h);
+
+	/*
+	 * Packet Reception Functions.
+	 */
+	void		recvDATA(Packet *p);
+	void 		capture(Packet *p);
+	void 		collision(Packet *p);
+
+	inline int initialized() {
+		return (cache_ && logtarget_ && Mac::initialized());
+	}
+
+	void mac_log(Packet *p) {
+		logtarget_->recv(p, (Handler*) 0);
+	}
+
+	inline double TX_Time(Packet *p) {
+		double t = DATA_Time((HDR_CMN(p))->size());
+		if(t < 0.0) {
+			Packet::free(p);
+			exit(1);
+		}
+		return t;
+	}
+
+public:
+	void  deferHandler(Event *e);
+	void  recvHandler(Event *e);
+	void  sendHandler(Event *e);
+
+private:
+
+	DeferSensorTimer	mhDefer_;
+	TxSensorTimer			mhTx_;
+	RxSensorTimer			mhRx_;
+
+	int code_;       // the code this node is currently receiving
+//      int base_X;      // the position X of the base station
+//      int base_Y;      // the position Y of the base station
+        int node_num_;   // this node's ID number
+	int ss_;         // max number of overlapping ss transmissions
+	int CHheard_;    // Number of other CH ADVs heard
+	int myADVnum_;   // Position of node's ADV among all ADVs
+
+	/* ============================================================
+	   Internal MAC State
+	   ============================================================ */
+
+	MacState		rx_state_;	// incoming state (MAC_RECV or MAC_IDLE)
+	MacState		tx_state_;	// outgoing state
+
+	inline int	is_idle(void);
+
+	NsObject*		logtarget_;
+
+	/* ============================================================
+	   Duplicate Detection state
+	   ============================================================ */
+
+	u_int16_t	sta_seqno_;		// next seqno that I'll use
+	int				cache_node_count_;
+	Host			*cache_;
+
+public:
+	inline int & node_num() { return node_num_; }
+	inline int & code() { return code_; }
+	inline int & myADVnum() { return myADVnum_; }
+
+};
+
+
+#endif /* __mac_sensor_h__ */
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/mac/mac-sensor-timers.cc ns-allinone-2.35/ns-2.35/mannasim/leach/mac/mac-sensor-timers.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/mac/mac-sensor-timers.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/mac/mac-sensor-timers.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,90 @@
+/******************************************************************
+ * This code was developed as part of the MIT uAMPS project.      *
+ ******************************************************************/
+
+#include "mac-sensor.h"
+#include "mac-sensor-timers.h"
+
+
+/* ======================================================================
+   Timers
+   ====================================================================== */
+
+void
+MacSensorTimer::start(Packet *p, double time)
+{
+	Scheduler &s = Scheduler::instance();
+
+	assert(busy_ == 0);
+
+	busy_ = 1;
+	paused_ = 0;
+	stime = s.clock();
+	rtime = time;
+	assert(rtime >= 0.0);
+
+	s.schedule(this, p, rtime);
+}
+
+void
+MacSensorTimer::stop(Packet *p)
+{
+	Scheduler &s = Scheduler::instance();
+
+	assert(busy_);
+
+	if(paused_ == 0)
+		s.cancel((Event *)p);
+
+	busy_ = 0;
+	paused_ = 0;
+	stime = 0.0;
+	rtime = 0.0;
+}
+
+/* ======================================================================
+   Defer Timer
+   ====================================================================== */
+
+void    
+DeferSensorTimer::handle(Event *e)
+{       
+	busy_ = 0;
+	paused_ = 0;
+	stime = 0.0;
+	rtime = 0.0;
+
+	mac->deferHandler(e);
+}
+
+/* ======================================================================
+   Receive Timer
+   ====================================================================== */
+
+void    
+RxSensorTimer::handle(Event *e)
+{       
+	busy_ = 0;
+	paused_ = 0;
+	stime = 0.0;
+	rtime = 0.0;
+
+	mac->recvHandler(e);
+}
+
+
+/* ======================================================================
+   Send Timer
+   ====================================================================== */
+
+void    
+TxSensorTimer::handle(Event *e)
+{       
+	busy_ = 0;
+	paused_ = 0;
+	stime = 0.0;
+	rtime = 0.0;
+
+	mac->sendHandler(e);
+}
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/mac/mac-sensor-timers.h ns-allinone-2.35/ns-2.35/mannasim/leach/mac/mac-sensor-timers.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/mac/mac-sensor-timers.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/mac/mac-sensor-timers.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,65 @@
+/******************************************************************
+ * This code was developed as part of the MIT uAMPS project.      *
+ ******************************************************************/
+
+#ifndef __mac_sensor_timers_h__
+#define __mac_sensor_timers_h__
+
+/* ======================================================================
+   Timers
+   ====================================================================== */
+class MacSensor;
+
+class MacSensorTimer : public Handler {
+public:
+	MacSensorTimer(MacSensor* m, double s = 0) : mac(m) {
+		busy_ = paused_ = 0; stime = rtime = 0.0; slottime_ = s;
+	}
+
+	virtual void handle(Event *e) = 0;
+
+	virtual void start(Packet *p, double time);
+	virtual void stop(Packet *p);
+	virtual void pause(void) { assert(0); }
+	virtual void resume(void) { assert(0); }
+
+	inline int busy(void) { return busy_; }
+	inline int paused(void) { return paused_; }
+	inline double slottime(void) { return slottime_; }
+	inline double expire(void) {
+		return ((stime + rtime) - Scheduler::instance().clock());
+	}
+
+protected:
+	MacSensor 	*mac;
+	int		busy_;
+	int		paused_;
+	Event		intr;
+	double		stime;	// start time
+	double		rtime;	// remaining time
+	double		slottime_;
+};
+
+
+class DeferSensorTimer : public MacSensorTimer {
+public:
+	DeferSensorTimer(MacSensor *m, double s) : MacSensorTimer(m,s) {}
+	void	handle(Event *e);
+};
+
+class RxSensorTimer : public MacSensorTimer {
+public:
+	RxSensorTimer(MacSensor *m) : MacSensorTimer(m) {}
+
+	void	handle(Event *e);
+};
+
+class TxSensorTimer : public MacSensorTimer {
+public:
+	TxSensorTimer(MacSensor *m) : MacSensorTimer(m) {}
+
+	void	handle(Event *e);
+};
+
+#endif /* __mac_sensor_timers_h__ */
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/rca/rcagent.cc ns-allinone-2.35/ns-2.35/mannasim/leach/rca/rcagent.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/rca/rcagent.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/rca/rcagent.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,213 @@
+/*************************************************************************
+ *
+ * This code was developed as part of the MIT SPIN project. (June, 1999)
+ *
+ *************************************************************************/
+
+#include "mannasim/leach/app/leachApp.h"
+
+#include "object.h"
+#include "agent.h"
+#include "trace.h"
+#include "packet.h"
+#include "scheduler.h"
+
+#include "mac.h"
+#include "ll.h"
+//#include "cmu-trace.h"
+
+#include "rcagent.h"
+#include "rtp.h"
+#include "random.h"
+#include "ip.h"
+
+#include "mannasim/leach/mac/mac-sensor.h"
+
+
+static class RCAgentClass : public TclClass {
+    public:
+        RCAgentClass() : TclClass("Agent/RCAgent") {}
+        TclObject* create(int, const char*const*) {
+            return (new RCAgent());
+        }
+} class_rc_agent;
+
+RCAgent::RCAgent() : Agent(PT_RCA)
+{
+    mac = NULL;
+    ll = 0;
+
+    bind("packetSize_", &size_);
+    bind("packetMsg_", &packetMsg_);
+    bind("distEst_", &distEst_);
+}
+
+RCAgent::~RCAgent()
+{
+}
+
+    int
+RCAgent::command(int argc, const char*const* argv)
+{
+    TclObject *obj;  
+    Tcl& tcl = Tcl::instance();
+
+    if (argc == 3) {
+        if(strcmp(argv[1], "log-target") == 0) {
+            log_target = (Trace*) TclObject::lookup(argv[2]);
+            if(log_target == 0)
+                return TCL_ERROR;
+            return TCL_OK;
+        } else if(strcmp(argv[1], "log") == 0) {
+            log(argv[2]);
+            return TCL_OK;
+        }
+    } else if (argc == 4)  {
+        if (strcasecmp(argv[1], "add-ll") == 0) {
+            if( (obj = TclObject::lookup(argv[2])) == 0) {
+                fprintf(stderr, "RCAgent: %s lookup of %s failed\n", argv[1],
+                        argv[2]);
+                return TCL_ERROR;
+            }
+            ll = (NsObject*) obj;
+            if( (obj = TclObject::lookup(argv[3])) == 0) {
+                fprintf(stderr, "RCAgent: %s lookup of %s failed\n", argv[1],
+                        argv[2]);
+                return TCL_ERROR;
+            }
+            mac = (Mac*) obj;
+            return TCL_OK;
+        }
+    } 
+
+    if (strcmp(argv[1], "sendmsg") == 0) {
+        if (argc < 6) {
+            fprintf(stderr, "RCAgent: %s needs argc >= 6\n", argv[1]);
+            return TCL_ERROR;
+        } 
+        int mac_dst;
+        if (Tcl_GetInt(tcl.interp(),(char *)argv[4], &mac_dst) != TCL_OK) {
+            fprintf(stderr, "RCAgent: could not convert %s to int\n", argv[4]);
+            return TCL_ERROR;
+        }
+        if (argc == 6) {
+            RCAgent::sendmsg(atoi(argv[2]), argv[3], mac_dst, -1, 10, 0, atoi(argv[5]));
+            return (TCL_OK);
+        }
+        int link_dst;
+        if (Tcl_GetInt(tcl.interp(),(char *)argv[5], &link_dst) != TCL_OK) {
+            fprintf(stderr, "RCAgent: could not convert %s to int\n", argv[5]);
+            return TCL_ERROR;
+        }
+        if (argc == 7) {
+            RCAgent::sendmsg(atoi(argv[2]), argv[3], mac_dst, link_dst, 10, 0, atoi(argv[6]));
+            return (TCL_OK);
+        }
+        double dist_to_dest;
+        if (Tcl_GetDouble(tcl.interp(),(char *)argv[6], &dist_to_dest) != TCL_OK) {
+            fprintf(stderr, "RCAgent: could not convert %s to double\n", argv[6]);
+            return TCL_ERROR;
+        }
+        if (argc == 8) {
+            RCAgent::sendmsg(atoi(argv[2]),argv[3],mac_dst,link_dst,dist_to_dest,0, atoi(argv[7]));
+            return (TCL_OK);
+        }
+        int code;
+        if (Tcl_GetInt(tcl.interp(),(char *)argv[7], &code) != TCL_OK) {
+            fprintf(stderr, "RCAgent: could not convert %s to int\n", argv[7]);
+            return TCL_ERROR;
+        }
+        if (argc == 9) {
+            RCAgent::sendmsg(atoi(argv[2]), argv[3], mac_dst, link_dst, dist_to_dest, code, atoi(argv[8]));
+            return (TCL_OK);
+        } else {
+            fprintf(stderr, "RCAgent: %s needs argc <= 9\n", argv[1]);
+            return TCL_ERROR;
+        }
+    }
+
+    return Agent::command(argc, argv);
+}
+
+void RCAgent::sendmsg(int data_size, const char* meta_data, int destination, int sendto, double dist_to_dest, int code, int packetMsg)
+{
+    //	printf("sendmsg: strlen(meta_data) = %d\n", strlen(meta_data));
+
+    sendmsg(data_size, meta_data, strlen(meta_data), destination, sendto, dist_to_dest, code, packetMsg);
+}
+
+void RCAgent::sendmsg(int data_size, const char* meta_data, int meta_size, int mac_dst, int link_dst, double dist_to_dest, int code, int packetMsg) 
+{
+
+    dst_.port_ = 0;
+    here_.port_ = 0;
+
+    Packet *p = allocpkt();
+    hdr_cmn *hdr = HDR_CMN(p);
+    hdr->size() = data_size;
+
+    hdr_rca *rca_hdr = HDR_RCA(p);
+    //  rca_hdr->msg_type() = packetMsg_;
+    rca_hdr->msg_type() = packetMsg;
+    rca_hdr->set_meta(meta_data, meta_size);
+    rca_hdr->rca_mac_dst() = mac_dst;
+    rca_hdr->rca_link_dst() = link_dst;
+    rca_hdr->rca_mac_src() = mac->addr();
+    rca_hdr->rca_link_src() = ((LeachApp *) app_)->sensor_node()->nodeid();
+    rca_hdr->get_dist() = dist_to_dest;
+    rca_hdr->get_code() = code;
+
+    hdr_mac* mh = HDR_MAC(p);
+    mh->set(MF_DATA, mac->addr(), mac_dst);
+
+    //  printf("Sending: Type=%d data_size=%d\n\tSource=%x\n\tTarget=%x\n\tDistance=%lf\n",rca_hdr->msg_type(), hdr->size(), rca_hdr->rca_src(),rca_hdr->rca_mac_dst(), dist_to_dest);
+    //printf("\tLink_dst = %x\n",rca_hdr->rca_link_dst());
+    //fflush(stdout);
+
+    //Packet::PrintRcHeader(p,"RCAgent");
+
+    //  Scheduler::instance().schedule(ll, p, 0); 
+    target_->recv(p);
+
+    return;
+}
+
+void RCAgent::recv(Packet* p, Handler*)
+{
+    hdr_cmn *hdr = HDR_CMN(p);
+    hdr_rca *rca_hdr = HDR_RCA(p);
+
+    if (app_ && (rca_hdr->rca_link_dst() < 0 || rca_hdr->rca_link_dst() == ((LeachApp *) app_)->sensor_node()->nodeid()))
+    {
+        //  printf("Receiving: Link_dst = %x, Type=%d data_size=%d\n\tMeta = %s, source = %d\n",rca_hdr->rca_link_dst(),rca_hdr->msg_type(), hdr->size(), rca_hdr->meta(),rca_hdr->rca_src());
+        //  fflush(stdout);
+
+        packetMsg_ = rca_hdr->msg_type();
+        distEst_ = rca_hdr->dist_est();
+
+        ((LeachApp *) app_)->recv(packetMsg_, distEst_, rca_hdr->rca_link_dst(), hdr->size(), rca_hdr->meta(),
+                                  rca_hdr->meta_size(), rca_hdr->rca_mac_src(), rca_hdr->rca_link_src());
+    }
+    //  else
+    //    printf("Pacote descartado por %d\n", ((LeachApp *) app_)->sensor_node()->nodeid());
+
+    /*
+     * didn't expect packet (or we're a null agent?)
+     */
+    Packet::free(p);
+}
+
+
+void RCAgent::log(const char *msg)
+{
+    if (!log_target) return;
+
+    Scheduler& s = Scheduler::instance();
+
+    sprintf(log_target->pt_->buffer(),
+            "C %.5f %s",
+            s.clock(),
+            msg);
+    log_target->pt_->dump();
+}
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/rca/rcagent.h ns-allinone-2.35/ns-2.35/mannasim/leach/rca/rcagent.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/rca/rcagent.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/rca/rcagent.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ * This code was developed as part of the MIT SPIN project. (June, 1999)
+ *
+ *************************************************************************/
+
+
+#ifndef ns_rca_h
+#define ns_rca_h
+
+#include "math.h"
+#include "object.h"
+#include "agent.h"
+#include "trace.h"
+#include "packet.h"
+#include "priqueue.h"
+#include "mac.h"
+#include "random.h"
+
+#include "agent.h"
+#include "app.h"
+
+//#include "../../sensorBaseApp.h"
+
+#define SAMPLERATE 8000
+#define ADV 0
+#define REQ 1
+#define DATA 2
+#define RESEND 3
+
+class RCAgent : public Agent {
+public:
+  RCAgent();
+  ~RCAgent();
+  inline void sendmsg(int data_size, const char* meta_data, int destination, int sendto, double dist_to_dest, int code, int packetMsg);
+  void sendmsg(int data_size, const char* meta_data, int meta_size, int mac_dst, int link_dst, double dist_to_dest, int code, int packetMsg);
+
+  virtual void recv(Packet*, Handler*);
+  void log(const char *msg);
+  int command(int argc, const char*const* argv);
+
+protected:
+  int packetMsg_;
+  int packetSize_;
+  double distEst_;
+
+private:
+
+  NsObject *ll;            // our link layer object 
+  Mac *mac;    // our MAC layer object
+
+  Trace *log_target;  // log target
+
+public:
+  inline Mac * getMAC() { return mac; }
+};
+
+#endif
+
+
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/rca/rca-ll.cc ns-allinone-2.35/ns-2.35/mannasim/leach/rca/rca-ll.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/rca/rca-ll.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/rca/rca-ll.cc	2009-11-12 15:43:37.000000000 +0100
@@ -0,0 +1,66 @@
+/*************************************************************************
+ *
+ * This code was developed as part of the MIT SPIN project. (June, 1999)
+ *
+ *************************************************************************/
+
+
+#include "delay.h"
+//#include "object.h"
+#include "packet.h"
+
+//#include "debug.h"
+#include <list>
+#include "arp.h"
+#include "topography.h"
+#include "trace.h"
+#include "node.h"
+#include "mac.h"
+#include "ll.h"
+#include "mannasim/leach/rca/rca-ll.h"
+#include "random.h"
+
+static class RCALinkLayerClass : public TclClass {
+    public:
+        RCALinkLayerClass() : TclClass("RCALinkLayer") {}
+        TclObject* create(int, const char*const*) {
+            return (new RCALinkLayer);
+        }
+} class_rcalinklayer;
+
+void RCALinkLayer::sendDown(Packet* p)
+{  
+    Scheduler& s = Scheduler::instance();
+    hdr_rca *rcah = HDR_RCA(p);
+    hdr_ll *llh = HDR_LL(p);
+    char *mh = (char*)p->access(hdr_mac::offset_);
+
+    llh->seqno() = ++seqno_;
+    llh->lltype() = LL_DATA;
+
+    mac_->hdr_src(mh, mac_->addr());
+    mac_->hdr_type(mh, ETHERTYPE_IP);
+    mac_->hdr_dst((char*) HDR_MAC(p), rcah->rca_mac_dst());
+
+    //  Packet::PrintRcHeader(p,"Link Outgoing");
+
+    //  mac_->hdr_dst((char*)HDR_MAC(p),rcah->rca_mac_dst());
+    //s.schedule(downtarget_, p, mindelay_ / 2 + delay_ * Random::uniform());
+    s.schedule(downtarget_, p, delay_);
+}
+
+
+void RCALinkLayer::sendUp(Packet* p)
+{  
+    Scheduler& s = Scheduler::instance();
+    hdr_rca *rcah = HDR_RCA(p);
+
+    //  Packet::PrintRcHeader(p,"Link Incomming");
+    if (hdr_cmn::access(p)->error() > 0) {
+        printf("Warning!  %d dropping packet from %d b/c it has an error.\n", rcah->rca_mac_dst(), rcah->rca_mac_src());
+        fflush(stdout);
+        drop(p);
+    } else
+        s.schedule(uptarget_, p, delay_);
+}
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/leach/rca/rca-ll.h ns-allinone-2.35/ns-2.35/mannasim/leach/rca/rca-ll.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/leach/rca/rca-ll.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/leach/rca/rca-ll.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,29 @@
+/*************************************************************************
+ *
+ * This code was developed as part of the MIT SPIN project. (June, 1999)
+ *
+ *************************************************************************/
+
+
+#ifndef rca_ll_h
+#define rca_ll_h
+
+#include "delay.h"
+#include "queue.h"
+
+#include "arp.h"
+#include "node.h"
+#include "god.h"
+
+class RCALinkLayer : public LL {
+    public:
+        RCALinkLayer() : LL() {};
+    private:
+        virtual void  sendDown(Packet* p);
+        virtual void  sendUp(Packet* p);
+};
+
+#endif
+
+
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/onDemandData.cc ns-allinone-2.35/ns-2.35/mannasim/onDemandData.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/onDemandData.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/onDemandData.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,78 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// This class represents data requests from an autosider of the Wireless  
+/// Sensor Network. This kind of request is interesting for on demand  data
+/// dissemination where dissemination only occurs when the outsider request
+/// data.
+///
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#include "onDemandData.h"
+
+/// For Mannasim in NS2.35; inserted by Paul S : http://paultsr.in
+/// Default constructor, invokes the request_type parameter constructor
+/// with default value.
+//OnDemandData :: OnDemandData()
+//{
+	/// REAL request type is default.
+//	OnDemandData::OnDemandData(REAL); 
+//}
+			
+/// Constructor. The request type of the OnDemandData is passed as
+/// parameter. Note that the superclass constructor (SensedData) is also
+/// called with ON_DEMAND_DATA AppDataType.
+OnDemandData :: OnDemandData(int request_type) : SensedData(ON_DEMAND_DATA) 
+{
+	this->request_type_ = request_type;
+}
+
+/// Copy constructor. The OnDemandData is passed as parameter.
+OnDemandData :: OnDemandData(OnDemandData & data) : SensedData(data)
+{
+	request_type_ = data.requestType();
+}
+
+/// Returns the size, in bytes, of the object.
+int OnDemandData :: size() const
+{
+	return sizeof(OnDemandData);
+}
+
+/// Creates a copy of the OnDemandData object.
+AppData * OnDemandData ::  copy()
+{
+	return new OnDemandData(*this);
+}
+
+/// Returns the address-of the request type field. Use this function carrefully.
+int & OnDemandData :: requestType()
+{
+	return request_type_;
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/onDemandData.h ns-allinone-2.35/ns-2.35/mannasim/onDemandData.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/onDemandData.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/onDemandData.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,88 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// This class represents data requests from an autosider of the Wireless  
+/// Sensor Network. This kind of request is interesting for on demand  data
+/// dissemination where dissemination only occurs when the outsider request
+/// data.
+///
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#ifndef on_demand_data_
+#define on_demand_data_
+
+/// Request type possible values. 
+/// REAL - the node collects new data.
+/// BUFFER - the node gets data from its buffer.
+/// AVERAGE - the node gets data from the average of all data from its buffer.
+enum
+{
+	REAL   =  0,
+	BUFFER =  1,
+	AVERAGE = 2
+};
+
+#include <common/ns-process.h>
+#include "sensedData.h"
+
+/// Class that encapsulates the request messages functionality.
+///
+/// extends SensedData
+class OnDemandData : public SensedData{
+
+	public:
+		
+		/// Constructors.
+		OnDemandData();
+		OnDemandData(int request_type);
+		OnDemandData(OnDemandData &data);
+
+		/// Size of the object.
+		int size() const;
+		
+		/// Creates a copy of the object.
+		AppData * copy();
+		
+		/// Returns the OnDemandData request type.
+		int & requestType();
+		
+	private:
+	
+		/// Request type of OnDemandData. Possible values BUFFER,
+		/// REAL and AVERAGE
+		int request_type_;
+		
+		//n�o sei se precisa. Acho melhor colocar fun��o no SensedData 
+		//que retornatamanho do infoRepository
+		//indicates the number of parameters (OnDemandParameters)
+		//	int parameters_amount_;
+};
+
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/onDemandParameter.cc ns-allinone-2.35/ns-2.35/mannasim/onDemandParameter.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/onDemandParameter.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/onDemandParameter.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,70 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// This class represents the queries submited within a OnDemandData 
+/// request message. Contains the requested data and a set of operations
+/// allowed to be performed to get the data (for example, get data if 
+/// temperature is GREATER_THAN 50 celsius degrees).
+/// 
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#include "onDemandParameter.h"
+
+/// Constructor. Requested data and operation performed on it are passed
+/// as parameters.
+OnDemandParameter :: OnDemandParameter(AppData* data, int operation)
+									 : AppData(ON_DEMAND_PARAMETER)
+{
+	this->data_ = data;
+	this->operation_ = operation;
+}
+		
+/// Returns OnDemandParameter object size in bytes.
+int OnDemandParameter :: size() const
+{
+	return sizeof(OnDemandParameter);
+}
+
+/// Creates a copy of OnDemandParameter object.
+AppData * OnDemandParameter :: copy()
+{
+	return new OnDemandParameter(data_, operation_);
+}
+
+/// Returns the address of operation_ field. Use this function carrefully.
+int & OnDemandParameter :: operation()
+{
+	return operation_;
+}
+
+/// Returns the requested data.
+AppData * OnDemandParameter :: data()
+{
+	return data_;
+}
\ No newline at end of file
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/onDemandParameter.h ns-allinone-2.35/ns-2.35/mannasim/onDemandParameter.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/onDemandParameter.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/onDemandParameter.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,80 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// This class represents the queries submited within a OnDemandData 
+/// request message. Contains the requested data and a set of operations
+/// allowed to be performed to get the data (for example, get data if 
+/// temperature is GREATER_THAN 50 celsius degrees).
+///
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#ifndef on_demand_parameter_h_
+#define on_demand_parameter_h_
+
+/// Comparation operations supported.
+enum
+{
+	GREATER_THAN = 0,
+	LESS_THAN 	 = 1,
+	EQUAL 		 = 2
+};
+
+#include <common/ns-process.h>
+
+/// Represents a query (each item) of the request message (OnDemandData).
+///
+/// extends AppData
+class OnDemandParameter : public AppData
+{
+	public:
+	
+		/// Constructor.
+		OnDemandParameter(AppData* data, int operation);
+		
+		/// Returns the size of the object.
+		int size() const;
+		
+		/// Creates a copy of the object.		
+		AppData * copy();
+		
+		/// Accessor methods
+		int & operation();
+		AppData * data();
+	
+	private:
+		
+		/// Data requested.
+		AppData* data_; 
+		
+		/// Type of operation. Supported values nowadays:
+		/// GREATER_THAN, LESS_THAN, EQUAL
+		int operation_;  
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/processing.cc ns-allinone-2.35/ns-2.35/mannasim/processing.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/processing.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/processing.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,258 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Class that simulates the processing activity on sensed data. It 
+/// constains a processed data buffer witch is accessed  by the sensing 
+/// in orther to disseminate processing results. Processing is a 
+/// base class that can be specialized to simulate different types of data 
+/// processing algorithms.
+/// 
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#include "processing.h"
+
+/// Default constructor. Only call superclass constructor.
+Processing::Processing() : TclObject()
+{
+}
+
+/// NS-2 command function overloaded. Deals with TCL script commands to C++ 
+/// implementation.
+int Processing::command(int argc, const char*const* argv)
+{
+	if (argc == 3)
+	{
+		if (strcmp("node",argv[1]) == 0)
+		{
+			sensor_node_ = (SensorNode*)TclObject::lookup(argv[2]);
+			if (sensor_node_)
+				return TCL_OK;
+			fprintf(stderr,"Error: %s object not found",argv[2]);
+			return TCL_ERROR;
+		}
+	}
+    return TclObject::command(argc, argv);
+}
+
+/// Receives common nodes sensed data from a EVENT_DRIVEN wireless sensor
+/// application. Verifies whether an event (for example, temperature sensed
+/// greater than X) occured or not. If so, process it and give it to 
+/// dissemination. Otherwise, drop the information.
+AppData* Processing::processSensedData(AppData* data_, AppData* eventData_)
+{
+   
+    /// This activity wastes sensor node energy! PROCESSING WASTE HERE!
+	((Battery*)sensor_node_->energy_model())->DecrProcessingEnergy(
+									EVENT_CHECK_INSTRUCTIONS,
+									sensor_node_->instructionsPerSecond(),
+									sensor_node_->processingPower());
+
+	if(eventData_->checkEvent(data_))
+	{
+		printf("Processing::processSensedData - Event detected!\n");
+       	return data_;
+	}
+	else
+	{
+		return NULL;
+	}
+}
+
+/// Method that deals with request messagens. First the request type is
+/// retrieved from data, then for each OnDemandParameter associated
+/// with the request message a specific process, based on query request,
+/// is realized.
+AppData * Processing::processRequest(AppData* data)
+{
+	
+	/// Data received isn't OnDemandData.
+	if(data->type() != ON_DEMAND_DATA)
+	{
+		fprintf(stderr,"The data received is not a onDemandData.");
+		return NULL;
+	}
+	
+	OnDemandData* onDemandData = (OnDemandData*)data;
+	int request_type = onDemandData->requestType();
+	AppDataList list = onDemandData->getData();
+	
+	AppDataList::iterator it;
+	OnDemandParameter* parameter;
+  
+	for (it = list.begin(); it != list.end(); it++)
+	{
+		if(((AppData*)(*it))->type() != ON_DEMAND_PARAMETER)
+		{
+			fprintf(stderr,"The data received is not a onDemandParameter.");
+			return NULL;
+		}
+		
+		/// Gets OnDemandParameter associated with request an process it.
+		parameter = (OnDemandParameter*)(*it);
+		return (process_request_data(parameter, request_type));
+	}
+}
+
+/// Manages diferent requests from an outsider observer. The request_type 
+/// parameter is used to select the further data processing
+AppData* Processing::process_request_data(OnDemandParameter* parameter, int request_type)
+{
+	int operation = parameter->operation();
+	AppData* data_ = parameter->data();
+
+	/// Choose the correct method given the request type.
+	switch (request_type)
+	{
+		case REAL:
+			return process_real_request(data_, operation);
+			break;
+		
+		case BUFFER:
+		    return process_buffer_request(data_, operation);
+		    break;
+		    
+    	case AVERAGE:
+    		return process_average_request(data_, operation);
+    		break;
+    	
+    	default:
+    		fprintf(stderr,"Processing::process_request_data - Invalid Request Type.");
+			break;
+	}
+	return NULL;	
+}
+
+/// Process request messages of REAL type. In this kind of data request,
+/// the sensor node drops all data from its buffer, collect new one and 
+/// process it.
+AppData* Processing::process_real_request(AppData* data_, int operation)
+{
+	/// New synthetic data needs to be generated. The applications list of 
+	/// data generator is used.
+	DataGenList list = app_->getGenList();
+	DataGenList::iterator it;
+	
+	DataGenerator* gen;
+	AppData* newData;
+	
+	/// Processed data.
+	SensedData* responseData = new SensedData();
+
+  	/// For each data generator associated with the application app_...
+  	for(it = list.begin(); it != list.end(); it++)
+  	{
+  		gen = (*it);
+  		
+  		/// ... checks if generated data type is the same of the sample data...
+  		if(gen->type() == data_->type())
+  		{
+  			/// ... generates new data and process it.
+  			newData = gen->collect();
+  			if(data_->compareData(newData, operation))
+  			{
+  				responseData->insertNewData(newData);
+  				return responseData;
+  			}
+  		}
+  	}
+	return NULL;
+}
+
+/// Process request messages of BUFFER type. In this kind of data request,
+/// data storage in sensor data buffer is processed and if satisfys the 
+/// request message it is given to dissemination.
+AppData* Processing::process_buffer_request(AppData* data_, int operation)
+{
+	AppDataList list;
+	
+	if(info_ != NULL)
+	{
+		list = info_->getData();
+	}
+	else
+	{
+		printf("Processing::process_buffer_request - Buffer is empty.\n");
+		return NULL;
+	}
+ 
+	AppData* bufferData_;
+	AppDataList::iterator it;
+ 	SensedData* responseData_ = new SensedData();
+  
+  	//each AppData (temperature, ...) should have this method
+  	for(it = list.begin(); it != list.end(); it++)
+  	{
+  		bufferData_ = (*it);
+  		
+  		/// ... checks if buffer data type is the same of the sample data...
+  		if(bufferData_->type() == data_->type())
+  		{
+  			if(data_->compareData(bufferData_, operation))
+  			{
+	  			/// ... buffer data attends request requiriments, add it to
+	  			/// response data.
+				responseData_->insertNewData(bufferData_);
+      		}
+    	}
+  	}
+  
+  	/// There were data in buffer, disseminate it.
+  	if(responseData_->existsData())
+  	{
+  		return responseData_;
+  	}
+	return NULL;
+}
+
+/// Process request messages of AVERAGE type. In this kind of request messages
+/// an average of the data storage in sensor node buffer is computed and 
+/// returned to the dissemination.
+///
+/// NOT IMPLEMENTED YET.
+AppData * Processing::process_average_request(AppData* data_,int operation)
+{ 
+}
+
+/// Reset the processed data making it NULL.
+void Processing::resetData()
+{
+	info_ = NULL;
+}
+
+/// Returns data generated by the processing activity.
+SensedData * Processing::getProcessedData()
+{
+	return info_;
+}
+
+/// Set application attached to the wireless sensor application.
+void Processing::setApp(SensorBaseApp* app)
+{
+	app_ = app;
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/processing.h ns-allinone-2.35/ns-2.35/mannasim/processing.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/processing.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/processing.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,110 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Class that simulates the processing activity on sensed data. It 
+/// constains a processed data buffer witch is accessed  by the sensing 
+/// in orther to disseminate processing results. Processing is a 
+/// base class that can be specialized to simulate different types of data 
+/// processing algorithms.
+/// 
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#ifndef __processing_h__
+#define __processing_h__
+
+#include <common/packet.h>
+
+#include "battery.h"
+#include "sensorNode.h"
+#include "sensedData.h"
+#include "onDemandData.h"
+#include "dataGenerator.h"
+#include "onDemandParameter.h"
+
+/// Processor instructions count for aggregation and event check (greater than,
+/// equal...) operations.
+#define AGGREGATION_INSTRUCTIONS 200
+#define EVENT_CHECK_INSTRUCTIONS 200
+
+class SensorBaseApp;
+
+/// Simulates the sensor data processing activity.
+///
+/// extends TclObject
+class Processing : public TclObject
+{
+	public:
+	
+		/// Constructor.
+		Processing();
+		
+		/// ??? This method MUST be overloaded.
+		virtual void recvData(AppData* data_) = 0;
+	
+		/// NS-2 Function.
+		int command(int argc, const char*const* argv);
+        
+        /// Simulates sensed data processing. This method
+        /// MUST be oveloaded.
+        virtual void processSensedData(AppData* data_) = 0;
+        
+        /// Simulates sensed data processing. Deals wih event occurence 
+        /// verification for EVEN_DRIVEN applications. Don't need to be 
+        /// overloaded.
+		AppData* processSensedData(AppData* data_, AppData* eventData_);
+
+		/// Methods for methods for request messages treatment.
+		virtual AppData * processRequest(AppData* data);
+		virtual AppData * process_real_request(AppData* data_, int operation);
+		virtual AppData * process_buffer_request(AppData* data_, int operation);
+		virtual AppData * process_request_data(OnDemandParameter* parameter, int request_type);
+
+		/// NOT IMPLEMENTED YET.
+		virtual AppData * process_average_request(AppData* data_, int operation);
+		
+		/// Accessor methods
+		virtual SensedData* getProcessedData();
+		virtual void resetData();
+		virtual void setApp(SensorBaseApp* app);		
+		
+	protected:
+	
+		/// Processed data buffer.
+		SensedData* info_;
+		
+		/// Application attached to the wireless sensor application. Used 
+		/// in on demand processing. 
+		SensorBaseApp * app_;
+		
+		/// Sensor node where the processing takes place. Used for energy
+		/// contability propose.
+		SensorNode* sensor_node_;
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/sensedData.cc ns-allinone-2.35/ns-2.35/mannasim/sensedData.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/sensedData.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/sensedData.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,173 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// This class represents sensing applications data. It is derived 
+/// from the NS-2 AppData. It includes methods to deal with messages
+/// type, source node identification, message copy, message log 
+/// management.
+///
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#include "sensedData.h"
+
+/// Default constructor, message type defined as SENSED_DATA.
+SensedData :: SensedData() : AppData(SENSED_DATA)
+{
+	timestamp_ = Scheduler::instance().clock();
+}
+
+/// Constructor with application data type defined by parameter. 
+SensedData :: SensedData(AppDataType type) : AppData(type)
+{
+	timestamp_ = Scheduler::instance().clock();
+}
+
+/// Copy constructor, creates a new SensedData object equals
+/// to data parameter.
+SensedData::SensedData(SensedData &data) : AppData(data)
+{
+	priority_ = 0; 
+	msgType_ = data.msgType();
+	node_id_ = data.node_id();
+	eventType_ = data.eventType();
+	timestamp_ = data.timeStamp();
+	
+	AppDataList list = data.getData();
+	AppDataList::iterator it;
+	for (it = list.begin();it != list.end(); it++)
+	{
+		infoRepository.push_back(*it);
+	}
+}
+
+/// Returns the all the data gathered in the sensing activity.
+AppDataList SensedData::getData()
+{
+	return infoRepository;
+}
+
+/// Returns the reference "&" to the message type variable (msgType_).
+int & SensedData::msgType()
+{
+	return msgType_;
+}
+
+/// Returns the reference "&" to the event type variable (eventType_).
+int & SensedData::eventType()
+{
+	return eventType_;
+}
+
+/// Returns the reference "&" to the source node identification for the
+/// message. (node_id_).
+int & SensedData::node_id()
+{
+	return node_id_;
+}
+
+/// Returns the reference "&" to the timestamp variable (timestamp_).
+double & SensedData::timeStamp()
+{
+	return timestamp_;
+}
+
+/// Returns the message priority. 
+int SensedData::priority()
+{
+	return priority_;
+}
+
+/// Ajusts the message�s priority. 
+void SensedData::set_priority(int p)
+{
+	priority_ = p;
+}
+
+/// Inserts new application data (AppData) into data log 
+/// (infoRepository).
+void SensedData::insertNewData(AppData* data)
+{
+	/// If bufferRepository size equals sensor buffer size
+	/// remove the oldest information (FIFO policy).
+	if(infoRepository.size() == BUFFER_SIZE)
+	{
+		infoRepository.erase(infoRepository.begin());
+	}
+	
+	/// Inserts data that has just arrived into the SensedData
+	/// infoRepository 
+	infoRepository.push_back(data);
+}
+
+/// Informs the message�s size. Actually only calls msgSize function. 
+int SensedData::size()
+{
+	return msgSize();
+}
+
+/// Informs the message�s size. Recursivelly adds the size of all 
+/// sensed data returns the total size of messages.
+int SensedData::msgSize()
+{
+	int size = sizeof(SensedData);
+
+	AppDataList::iterator it;
+	for (it = infoRepository.begin(); it != infoRepository.end(); it++)
+	{
+		size += (*it)->size();
+	}
+	return size;
+}
+
+/// Returns a copy of the sensed data, including message type, and
+/// all data from infoRepository.
+AppData * SensedData::copy()
+{
+	return new SensedData(*this);
+}
+
+/// Return a boolenan indicating if exists sensed data or not in the 
+/// infoRepository.
+bool SensedData::existsData()
+{
+	return !infoRepository.empty();
+}
+
+/// Returns the number of sensed data samples storaged in the 
+/// infoRepository.
+int SensedData::count()
+{
+	return infoRepository.size();
+}
+
+/// Makes the infoRepository empty.
+void SensedData::clear()
+{
+	infoRepository.clear();
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/sensedData.h ns-allinone-2.35/ns-2.35/mannasim/sensedData.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/sensedData.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/sensedData.h	2009-11-12 15:57:42.000000000 +0100
@@ -0,0 +1,109 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// This class represents sensing applications data. It is derived 
+/// from the NS-2 AppData. It includes methods to deal with messages
+/// type, source node identification, message copy, message log 
+/// management.
+///
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#ifndef __sensed_data__
+#define __sensed_data__
+
+#include <list>
+#include <vector>
+#include <scheduler.h>
+#include <common/ns-process.h>
+
+
+/// Databuffer size. Indicates how many samples can be stored.
+#define BUFFER_SIZE 100
+
+typedef list<int> GroupList;
+typedef vector<AppData*> AppDataList;
+
+/// The sensedData class encapsulates all information that needs to be
+/// fowarded by the node.
+/// extends NS-2 AppData
+class SensedData : public AppData
+{
+	public:
+	
+		/// Contructors
+		SensedData();
+		SensedData(AppDataType type);
+		SensedData(SensedData &data);
+
+		/// Accessor Methods
+		AppDataList getData();
+
+		int& msgType();
+		int& node_id();
+		int& eventType();
+		double & timeStamp();
+
+		int priority();
+		void set_priority(int p);
+		AppData* copy();
+
+		/// Inserts a new AppData in infoRepository
+		void insertNewData(AppData* data);
+
+		/// Informs if the infoRepository is empty or not
+		bool existsData();
+
+		/// infoRepository managment functions
+		int size();
+		int msgSize();
+		int count();
+		void clear();
+
+	private:
+
+		/// Message type
+		int msgType_;
+
+		/// Event type
+		int eventType_;
+
+		/// Source node identification
+		int node_id_;
+
+		double timestamp_;
+
+		/// Message priority
+		int priority_;
+
+		/// Data log from messages
+		AppDataList infoRepository;
+};
+
+#endif 
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/sensorBaseApp.cc ns-allinone-2.35/ns-2.35/mannasim/sensorBaseApp.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/sensorBaseApp.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/sensorBaseApp.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,191 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// 
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+///
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Implementation of the classes used by all common sensor nodes of a Wireless
+/// Sensor Network. These classes represents the sensing dynamics: sensing, 
+/// processing, and disseminating.
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+/// 
+#include "sensorBaseApp.h"
+
+
+/// Whenever the disseminating timer expires, the application disseminateData()
+/// method should be invoked. The timer should also be rescheduled.
+void DisseminatingTimer::expire(Event*)
+{
+	double dissT;
+	app_->disseminateData();
+	
+	dissT = app_->getExpireTime();
+	if (dissT != -1)
+	{
+		resched(dissT);
+	}
+}
+
+
+/// Default constructor. Binds TCL script parameters to C++ code variables and
+/// creates a disseminating timer.
+SensorBaseApp::SensorBaseApp():Application()
+{
+	bind("disseminating_type_",&disseminating_type_);
+	bind("disseminating_interval_",&disseminating_interval_);
+	bind("destination_id_",&destination_id_);
+	
+	dissTimer_ = new DisseminatingTimer(this);
+}
+
+/// NS-2 command function overloaded. Deals with TCL script commands to C++ 
+/// implementation.
+int SensorBaseApp::command(int argc, const char*const* argv)
+{
+	if(argc == 2)
+	{		
+		if(strcmp(argv[1],"start") == 0)
+		{
+			/// Initiates the sensing, processing and disseminating activity
+			SensorBaseApp::start();	
+			return TCL_OK;
+		}
+		if(strcmp(argv[1],"stop") == 0)
+		{
+			/// Stops the sensing, processing and disseminating activity
+			SensorBaseApp::stop();
+			return TCL_OK;
+		}
+	}
+	if(argc == 3)
+	{
+		if(strcmp("node", argv[1]) == 0)
+		{
+			/// Attach a node to the application
+			sensor_node_ = (SensorNode*)TclObject::lookup(argv[2]);
+			if (sensor_node_)
+			{
+				return TCL_OK;
+			}
+			fprintf(stderr,"Error: %s object not found",argv[2]);
+			return TCL_ERROR;
+		}
+		if (strcmp("attach-processing",argv[1]) == 0)
+		{
+			/// Attach a processing activity to the application
+			processing_ = (Processing*)TclObject::lookup(argv[2]);
+			processing_->setApp(this);
+			if (processing_)
+			{
+				return TCL_OK;
+			}
+			fprintf(stderr,"Error: %s object not found",argv[2]);
+			return TCL_ERROR;
+		}
+		if(strcmp(argv[1],"attach_data_generator") == 0)
+		{
+			/// Attach a data generator to the application
+			DataGenerator* gen = (DataGenerator*) TclObject::lookup(argv[2]);
+			if(!gen)
+			{
+				return TCL_ERROR;
+			}
+			gen->insertNewApp(this);
+			insertNewGenerator(gen);
+			return TCL_OK;
+		}
+	}
+	return Application::command(argc,argv);
+}
+
+/// Returns the expire time for diferente types of data dissemination.
+double SensorBaseApp::getExpireTime(){
+
+	switch(disseminating_type_)
+	{
+		case PROGRAMED:
+			return disseminating_interval_;
+		case CONTINUOUS:
+			return -1;
+		case ON_DEMAND:
+			return -1;
+		case EVENT_DRIVEN:
+			return -1;
+		default: 
+			fprintf(stderr, "Unrecognized type of dissemination!\n");
+			abort();
+			break;
+	}
+}
+
+/// Shedule the first processing/disseminating event if these activity type 
+/// isn�t the continuous one.
+void SensorBaseApp::start()
+{	
+	double dissT;
+	dissT = getExpireTime();
+	
+	if (dissT != -1)
+	{
+		dissTimer_->resched(dissT);
+	}
+
+	DataGenList::iterator it;
+	DataGenerator* gen;
+	for(it = gen_.begin(); it != gen_.end(); it++)
+	{	
+		gen = *it;
+		gen->start();
+	}
+}
+
+/// Drops all the scheduled events.
+void SensorBaseApp::stop()
+{	
+	if (dissTimer_->status() == TIMER_PENDING)
+	{
+		dissTimer_->cancel();
+	}
+
+	/// Stops all DataGenerators that are attached to this application.
+	DataGenList::iterator it;
+	DataGenerator* gen;
+	for(it = gen_.begin(); it != gen_.end(); it++)
+	{
+		gen = *it;
+		gen->stop();
+	}
+}
+
+/// Inserts a new DataGenerator to application DataGenerator list.
+void SensorBaseApp::insertNewGenerator(DataGenerator* gen)
+{
+	gen_.push_back(gen);
+}
+
+/// Returns the DataGenerator list for the application.
+DataGenList SensorBaseApp::getGenList()
+{
+	return gen_;
+}
+
+/// Return the sensor node attached to the application.
+SensorNode * SensorBaseApp::sensor_node()
+{ 
+	return sensor_node_;
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/sensorBaseApp.h ns-allinone-2.35/ns-2.35/mannasim/sensorBaseApp.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/sensorBaseApp.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/sensorBaseApp.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,168 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// 
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+///
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+///
+/// Base class for the other sensor nodes applications. It is an 
+/// abstract class that should be implemented in different ways 
+/// by specialized applications. It is derived from Application NS class
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+/// 
+#ifndef __sensing_app_h__
+#define __sensing_app_h__
+
+using namespace std;
+
+#include <list>
+#include <apps/app.h>
+#include <common/agent.h>
+#include <common/ns-process.h>
+#include <common/packet.h>
+#include <tools/rng.h>
+
+#include "battery.h"
+#include "processing.h"
+#include "sensorNode.h"
+#include "onDemandData.h"
+#include "dataGenerator.h"
+#include "onDemandParameter.h"
+
+
+/// Disseminate and sensing type enumeration
+enum
+{
+	PROGRAMED 	 = 0,
+	CONTINUOUS 	 = 1,
+	ON_DEMAND 	 = 2,
+	EVENT_DRIVEN = 3
+};
+
+#define TRAP_ 0
+#define MSG_BYTES_ 32
+#define INSTRUCTIONS_ 200
+#define SENSING_TIME_ 0.01
+#define DEFAULT_PORT_ 2020
+
+#define SENSOR_REPORT_ 0
+#define LOCALIZATION_ 1
+#define INITIAL_GROUP_ 2
+#define SOLICITATION_ 3
+//#define REQUEST_ 4
+#define DESTINATION_ 5
+
+
+class SensedData;
+class Processing;
+class SensorBaseApp;
+class DataGenerator;
+
+/// Type definition for a DataGeneration STL list.
+typedef list<DataGenerator*> DataGenList;
+
+/// Disseminating timer for collect data.
+class DisseminatingTimer : public TimerHandler {
+	
+	public:
+		DisseminatingTimer(SensorBaseApp* app) : TimerHandler(), app_(app) {}
+		inline virtual void expire(Event*);
+
+	protected:
+		
+		/// SensorBaseApp used to disseminate the data
+		SensorBaseApp* app_;
+};
+
+
+/// Base class for common-nodes, cluster-heads, managed nodes. Should be 
+/// specialized for each specific node application. 
+/// extends NS-2 Application class
+class SensorBaseApp : public Application{
+	
+	public:
+		/// standard constructor
+		SensorBaseApp();
+
+		/// NS-2 function
+		virtual int command(int argc, const char*const* argv);
+		
+		/// Control functions for simulation applications.
+		void start();
+		void stop();
+
+		/// Accessor methods.
+		DataGenList getGenList();
+		SensorNode * sensor_node();
+
+		friend class DisseminatingTimer;
+		friend class DataGenerator;
+		friend class Processing;
+
+	protected:	
+		/// Array of Application Data Generators. It should be especified in the 
+		/// moment of the application creation.
+		DataGenList gen_;
+
+		/// Instance of the object that processes sensed data.
+		Processing* processing_;
+
+		/// Refers to the sensor nodes that contains this application
+		SensorNode* sensor_node_;
+
+		/// Indicates the way the node disseminate sensed data.
+		/// See disseminating enumeration above for disseminating valid values.
+		int disseminating_type_;
+
+		/// Indicates the nodes disseminating interval.
+       /**
+		 * Used to determine the dissemination interval. If this interval is 
+		 * zero and the dissemination type is one, then the interval should be
+		 * obtained from a normal distribution. If the dissemination type
+		 * is 2, the dissemination will be determined by the received query 
+		 * or event.
+		 */
+		double disseminating_interval_;
+
+		/// Destination node for the sensed data. 
+		int destination_id_;
+
+		/// Dissemination timer, used for CONTINOUS and PROGRAMED dissemination.
+		DisseminatingTimer* dissTimer_;
+
+		virtual void insertNewGenerator(DataGenerator* gen);		
+		double getExpireTime();
+		
+		/// IMPORTANT: the next four methods should be overwitten by specialized
+		/// classes.
+		
+		/// Sends collected data (after processing activity) to the destination 
+		/// node.
+		virtual void disseminateData(){}
+
+		/// Sends collected data (after processing activity) to the destination 
+		/// node. Collected data is passed as a parameter.
+		virtual void disseminateData(AppData* data){}
+	
+		/// Receives sensed data and performs some kind of processing. These 
+		/// function should be overloaded.
+		virtual void recvSensedData(AppData* data_){};
+		virtual void recvSensedData(AppData* data_, AppData* eventData_){};
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/sensorNode.cc ns-allinone-2.35/ns-2.35/mannasim/sensorNode.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/sensorNode.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/sensorNode.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,148 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Class that describes all the variables and functions of a sensor node. 
+/// It can be used as an initial  approach to the development of new 
+/// sensor nodes types.
+///
+/// authors: Linnyer B. Ruiz
+///	         Fabr�cio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+/// 
+#include "sensorNode.h"
+ 
+
+// This static class creates a link between the C++ class and the TCL script 
+// in the simulation scenario.
+static class SensorNodeClass : public TclClass
+{
+	public:
+		SensorNodeClass() : TclClass("Node/MobileNode/SensorNode"){}
+		TclObject* create(int, const char*const*)
+		{
+			return (new SensorNode()); 
+		}
+}class_sensornode;
+
+
+/// SensorNode constructor. Binds TCL script parameters to C++ code variables
+/// and initialize all the three activites of a sensor node: sensing, processing
+/// and disseminating.
+SensorNode::SensorNode() : MobileNode()
+{
+	bind("sensingPower_",&sensingPower_);
+	bind("processingPower_",&processingPower_);
+	bind("instructionsPerSecond_",&instructionsPerSecond_);
+
+	sensorUseState = ON;
+	processorUseState = ON;
+	transceptorUseState = ON;
+}
+
+// NS-2 function
+int SensorNode::command(int argc, const char*const* argv)
+{
+	Tcl& tcl = Tcl::instance();
+
+	if(argc == 3){
+		if(strcmp(argv[1],"add-app") == 0)
+		{
+			/// Attach an application to the node.
+			Application* app = (Application*)TclObject::lookup(argv[2]);
+			apps_.push_back(app);
+			return TCL_OK;	
+		}
+	}
+	return MobileNode::command(argc,argv);
+}
+
+/// Performs a selfTest on the sensor node checking its proper functioning. 
+/// NOT YET IMPLEMENTED
+void SensorNode::selfTest(){}
+
+// Turns the sensor node off when necessary.
+void SensorNode::sleep()
+{
+	/// Using the energy model pointer, turns off the node�s transceptor.
+	((Battery*)energy_model())->setNodeOff();
+
+	/// Stops all the applications related to the node.
+	Tcl& tcl = Tcl::instance();
+	AppList::iterator it;
+	Application* app;
+	
+	for (it = apps_.begin(); it != apps_.end(); it++)
+	{
+		app = *it;
+		tcl.evalf("%s stop",app->name());
+	}
+
+	/// Set "off" to all states of node activity (sensing, processing and 
+	/// disseminating)
+	sensorUseState = OFF;
+	processorUseState = OFF;
+	transceptorUseState = OFF;
+}
+
+/// Turns the sensor node on when necessary.
+void SensorNode::wakeUp(){
+
+	// Using the energy model pointer, turns on the sensor node transceptor.
+	((Battery*)energy_model())->setNodeOn();
+
+	// Starts all the applications related to the node.
+	Tcl& tcl = Tcl::instance();
+	AppList::iterator it;
+	Application* app;
+	
+	for (it = apps_.begin(); it != apps_.end(); it++)
+	{
+		app = *it;
+		tcl.evalf("%s start",app->name());
+	}
+
+	/// Set "on" to all states of node activity (sensing, processing and 
+	/// disseminating)
+	sensorUseState = ON;
+	processorUseState = ON;
+	transceptorUseState = ON;
+}
+
+/// Returns node�s sensing power in Joules/Second.
+double SensorNode::sensingPower()
+{
+	return sensingPower_;
+}
+
+/// Returns node�s processing power in Joules/Second.
+double SensorNode::processingPower()
+{
+	return processingPower_;
+}
+
+/// Returns node�s instruction per second number.
+int SensorNode::instructionsPerSecond()
+{
+	return instructionsPerSecond_;
+}
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/sensorNode.h ns-allinone-2.35/ns-2.35/mannasim/sensorNode.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/sensorNode.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/sensorNode.h	2009-11-12 15:43:37.000000000 +0100
@@ -0,0 +1,107 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Class that describes all the variables and functions of a sensor node. 
+/// It can be used as an initial  approach to the development of new 
+/// sensor nodes types.
+///
+/// authors: Linnyer B. Ruiz
+///	         Fabr�cio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+/// 
+#ifndef __ns_sensornode_h__
+#define __ns_sensornode_h__
+
+#include <stdlib.h>
+#include <list>
+
+#include "app.h"
+#include "mobilenode.h"
+#include "battery.h"
+
+enum
+{
+	ON  = 0,
+	OFF = 1
+};
+
+typedef list<Application*> AppList;
+
+/// A class that represents a sensor node with its caracteristics and 
+/// functionality. 
+/// extends NS-2 MobileNode class
+class SensorNode : public MobileNode
+{
+	friend class Battery;
+	
+	public:		
+		
+		/// Constructor.
+		SensorNode();
+
+		/// NS-2 function.
+		virtual int command(int argc, const char*const* argv);
+
+		/// Accessor methods.
+		double sensingPower();
+		double processingPower();
+		int instructionsPerSecond();
+
+	protected:
+
+		/// List of applications associated with the node.
+		AppList apps_;
+
+		/// Indicates the number of instructions that the nodes processor can 
+		/// execute per time unit (usually seconds).
+		int instructionsPerSecond_;
+			
+		/// Indicates the energy consumption that a node has when it performs 
+		/// its processing activity - thsi value should be in Joules/Second.
+		double processingPower_;
+		
+		// Indicates the energy consumption that a node has, when it performs 
+		// its sensing activity - this value should be in Joules/Second.
+		double sensingPower_;
+
+		// Indicates whether the sensing activity is in use or not
+		int sensorUseState;
+
+		// Indicates whether the processing activity is in use or not
+		int processorUseState;
+
+		// Indicates wheter the transceptor activity is in use or not
+		int transceptorUseState;
+	
+		// Performs a test on the initial behavior of the node.
+		virtual void selfTest();
+
+		// Turns the node off when it is necessary.
+		virtual void sleep();
+
+		// Turns the node on when it is necessary.
+		virtual void wakeUp();	
+};
+
+#endif
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/temperatureAppData.cc ns-allinone-2.35/ns-2.35/mannasim/temperatureAppData.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/temperatureAppData.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/temperatureAppData.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,143 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Defines a temperature application data type. Encapsulates the 
+/// raw data from DataGenerator.
+/// 
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+/// 		 Julio Cesar e Melo
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#include "temperatureAppData.h"
+
+/// TemperatureAppData constructor. Sets temperature and colleted 
+/// time for the object, also calls super class constructor AppDataAttrsExporter() 
+/// with AppDataType temperature.
+TemperatureAppData::TemperatureAppData(double temperature, double sample_time) :
+								 AppDataAttrsExporter(TEMPERATURE_SENSED_DATA)
+{
+	data_ = temperature;
+	time_ = sample_time;
+}
+
+/// Checks if the value of the current object of this class is greater 
+/// than the value of the parameter object. Until now, we only implemented
+/// the GREATER THAN  option for EVENT DRIVEN network.
+bool TemperatureAppData::checkEvent(AppData* data_)
+{
+	double value = ((TemperatureAppData*)data_)->data();
+
+	if(value >= this->data())
+	{
+		return true;
+	}
+	else
+	{
+		return false;
+	}
+}
+
+/// Check if current value satisfies the condition especified by operation 
+/// and data parameters. This method is used in ON DEMAND network.
+bool TemperatureAppData::compareData(AppData* data, int operation)
+{
+  double value = ((TemperatureAppData*)data)->data();
+
+	switch (operation)
+	{
+		case GREATER_THAN:
+			return (value > this->data());
+
+		case LESS_THAN:
+			return (value < this->data());
+ 
+		case EQUAL:
+			return (value == this->data());
+
+		default:
+			fprintf(stderr,"TemperatureAppData::compareData - Invalid Operation.\n");
+			return false;
+	}
+}
+
+/// Sets atributes about temperature sensed data. Called by 
+/// CommonNodeDiffApp (directed difusion).
+/// 
+/// Created by Julio Cesar e Melo
+void TemperatureAppData::setAttributes(NRAttrVec * attrs)
+{
+	attrs->push_back(
+		SensedValueAttr.make(NRAttribute::IS, this->data()));
+}
+
+/// Returns the size of the temperatureAppData object. Size in bytes.
+int TemperatureAppData::size() const
+{
+	return sizeof(TemperatureAppData);
+}
+
+/// Creates a copy of the temperatureAppData object.
+AppData * TemperatureAppData::copy()
+{
+	return new TemperatureAppData(data_, time_);
+}
+
+/// Returns temperature data.
+double TemperatureAppData::data()
+{
+	return data_;
+}
+
+/// Ajusts temperature data.
+void TemperatureAppData::setData(double data)
+{
+	data_ = data;
+}
+	
+///	Returns timestamp for temperature data.
+double TemperatureAppData::time()
+{
+	return time_;
+}
+
+/// Ajusts timestamp for temperature data.
+void TemperatureAppData::setTime(double time)
+{
+	time_ = time;
+}
+/// Returns temperature data priority.
+void TemperatureAppData::setPriority(int p)
+{
+	priority_ = p;
+}
+
+/// Ajust temperature data priority.
+int & TemperatureAppData::getPriority()
+{
+	return priority_;
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/temperatureAppData.h ns-allinone-2.35/ns-2.35/mannasim/temperatureAppData.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/temperatureAppData.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/temperatureAppData.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,95 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Defines a temperature application data type. Encapsulates the 
+/// raw data from DataGenerator.
+/// 
+/// authors: Linnyer B. Ruiz
+///	         Fabricio A. Silva
+///			 Thais Regina de M. Braga 
+///  		 Kalina Ramos Porto
+/// 		 Julio Cesar e Melo
+///
+/// code revisor: Carlos Eduardo R. Lopes
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#ifndef __temperature_app_data__
+#define __temperature_app_data__
+
+#include <common/ns-process.h>
+#include <nr.hh>
+
+#include "onDemandParameter.h"
+#include "diffusion/attrsExporter.h"
+
+/// Creates a temperature application data type. This data type 
+/// represents the pure data collect by the sensor node. This data
+/// is sent to the processing module for futher treatment.
+class TemperatureAppData : public AppDataAttrsExporter
+{
+	public:
+		
+		/// Constructor, parameters are the data temperature collected
+		/// and timestamp 
+		TemperatureAppData(double temperature, double sample_time);
+		
+		/// Creates a copy of the object.
+		AppData* copy();
+		
+		/// Size, in bytes, of the object.
+		int size() const;
+		
+		/// Check if satisfies the condition especified by
+		/// operation and value. It is used in ON DEMAND network
+		bool compareData(AppData* data, int operation);
+
+		/// Check if the value is greater than this one.
+		/// It is used in EVENT DRIVEN network
+		bool checkEvent(AppData* data_);
+
+		/// Accessor methods
+		double data();
+		double time();
+		int& getPriority();	
+					
+		void setData(double data);	
+		void setTime(double time);
+		void setPriority(int p);
+
+		/// Set attributes of sensed data. This is called by CommonNodeDiffApp.
+		/// Changed by Julio Cesar e Melo.
+		virtual void setAttributes(NRAttrVec * attrs);
+
+	protected:
+	
+		/// Temperature data. 
+		double data_;
+		
+		/// Timestamp for temperature data.
+		double time_;
+		
+		/// Priority for temperature data.
+		int priority_;
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/temperatureDataGenerator.cc ns-allinone-2.35/ns-2.35/mannasim/temperatureDataGenerator.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/temperatureDataGenerator.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/temperatureDataGenerator.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,107 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// 
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+///
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Generates synthetic temperature data. Simulates a temperature sensor node
+/// sensing the environment.
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+/// 
+#include "temperatureDataGenerator.h"
+
+/// This static class creates a link between the C++ class and the TCL script 
+/// in the simulation scenario. Provides an instance of the 
+/// TemperatureDataGenerator class in the TCL simulation script. 
+static class TemperatureDataGeneratorClass : public TclClass
+{
+	public:
+		TemperatureDataGeneratorClass() : TclClass(
+			"DataGenerator/TemperatureDataGenerator"){}
+		TclObject* create(int, const char*const*)
+		{
+			return (new TemperatureDataGenerator);
+		}
+
+}class_temperature_data_generator;
+
+/// Constructor, binds TCL script parameters to C++ code variables and
+/// creates a disseminating timer.
+TemperatureDataGenerator::TemperatureDataGenerator() : 
+							DataGenerator(TEMPERATURE_SENSED_DATA)
+{
+
+	// Creates the random number that that generates the syntectic data.
+	rand_ = new RNG(RNG::HEURISTIC_SEED_SOURCE, 1);
+	
+	/// Get from the TCL script: data average, standard deviation, and maximum
+	/// Temperature value allowed.
+	bind("avg_measure",&avg_measure);
+	bind("std_deviation",&std_deviation);
+	bind("maximumTemperatureValue",&maximumTemperatureValue);
+}
+
+/// Temperature sensing simulation. This is the most important function since it
+/// creates the random data, encapsulates it on a AppData object and return it
+/// to the sensor node.
+AppData* TemperatureDataGenerator::collect()
+{
+	double t = rand_->normal(avg_measure, std_deviation);
+
+	printf("Temperature Data %f - Time %f\n",t,Scheduler::instance().clock());
+	TemperatureAppData* data = 
+		new TemperatureAppData(t, Scheduler::instance().clock());
+	
+	/// Returns an application data, that contains the temperature collected 
+	/// value
+	return data;
+}
+
+/// NS-2 command function overloaded. Deals with TCL script commands to C++ 
+/// implementation.
+int TemperatureDataGenerator::command(int argc, const char*const* argv)
+{
+	if(argc == 3)
+	{
+		if(strcmp("set-event",argv[1]) == 0)
+		{
+			avg_measure = atof(argv[2]);
+			printf("EVENT: New avg_measure: %.3f\n",atof(argv[2]));
+			return TCL_OK;
+		}
+   }
+   return DataGenerator::command(argc, argv);
+}
+
+/// Returns average measure for synthetic temperature generation.
+double TemperatureDataGenerator::getAvgMeasure()
+{
+	return avg_measure;
+}
+
+/// Sets average measure value for synthetic temperature generation.
+void TemperatureDataGenerator::setAvgMeasure(double avg_measure)
+{
+	this->avg_measure = avg_measure;
+}
+
+/// Returns the maximum allowed temperature value.
+TemperatureAppData* TemperatureDataGenerator::getMaximumAllowedValue()
+{
+	return new TemperatureAppData(maximumTemperatureValue,0.0);
+}
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/temperatureDataGenerator.h ns-allinone-2.35/ns-2.35/mannasim/temperatureDataGenerator.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/temperatureDataGenerator.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/temperatureDataGenerator.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,61 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// 
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+///
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// Generates synthetic temperature data. Simulates a temperature sensor node
+/// sensing the environment.
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+/// 
+#ifndef __temperature_data_generator__
+#define __temperature_data_generator__
+
+#include "dataGenerator.h"
+#include "temperatureAppData.h"
+
+/// Generate synthetic temperature data. Synthetic data is based on average and
+/// standard deviation values for a normal probability distribution. A maximum
+/// allowed value should also be set.
+/// extends DataGenerator
+class TemperatureDataGenerator : public DataGenerator
+{
+	public:
+		/// Constructor
+		TemperatureDataGenerator();
+		
+		/// Data sensing simulation function
+		AppData* collect();
+		
+		/// NS-2 function
+		virtual int command(int argc, const char*const* argv);
+
+		/// Accessor methods
+		double getAvgMeasure();
+		void setAvgMeasure(double avg_measure);
+		virtual TemperatureAppData* getMaximumAllowedValue();
+
+	protected:
+		RNG* rand_;
+
+		double avg_measure;		
+		double std_deviation;
+		double maximumTemperatureValue;
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/util/accounts.cc ns-allinone-2.35/ns-2.35/mannasim/util/accounts.cc
--- ns-allinone-2.35-orig/ns-2.35/mannasim/util/accounts.cc	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/util/accounts.cc	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,96 @@
+#include "accounts.h"
+
+/// 
+Accounts * Accounts :: instance()
+{
+	static Accounts single_instance;
+	return &single_instance;
+}
+
+Accounts::Accounts()
+{
+	nodes = 0;
+	groups_counter = 0;
+	nodes_per_group = 0;
+	consumed_energy = 0;
+	management_msgs_sent  = 0;
+	negotiation_msgs_sent = 0;
+}
+
+void Accounts::incr_sent_msgs()
+{
+	management_msgs_sent++;
+}
+
+void Accounts::incr_negotiation_msgs()
+{
+	negotiation_msgs_sent++;
+}
+
+void Accounts::incr_nodes(int number_of_nodes)
+{
+	nodes += number_of_nodes;
+}
+
+void Accounts::incr_energy_consumption(double consumption)
+{
+	consumed_energy += consumption;
+}
+
+void Accounts::incr_nodes_per_group(int number_of_nodes)
+{
+	nodes_per_group += number_of_nodes;
+	groups_counter++;
+}
+
+void Accounts::imprime(char * output_dir)
+{		
+	char * ophans = new char [60];
+	char * energy = new char [60];
+	char * sent_msgs = new char [60];
+	char * negotiation_msgs = new char [60];
+
+	strcpy(ophans, output_dir);
+	strcpy(energy, output_dir);
+	strcpy(sent_msgs, output_dir);	
+	strcpy(negotiation_msgs, output_dir);
+	
+	/* imprime em arquivo as msg enviadas */
+	FILE *sent_msgs_file;
+	
+	strcat(sent_msgs, "/management_msgs_sent.dat");
+	sent_msgs_file = fopen (sent_msgs, "a");
+	
+	fprintf(sent_msgs_file, "%d\n", management_msgs_sent);
+	fclose(sent_msgs_file);
+	/******************************************************/
+
+	/* imprime em arquivo a quantidade de nos �rf�os */
+	FILE * orphans_file;
+	
+	strcat(orphans, "/ophan_nodes.dat");
+	orphans_file = fopen (orphans, "a");
+	
+	fprintf(orphans_file, "%d\n", (NUMERO_NOS_COMUNS - nodes));
+	fclose(orphans_file);
+	/******************************************************/
+
+	/* imprime em arquivo a energia consumida, na m�dia, pelos CHs */
+	FILE * energy_file;
+	
+	strcat(energy, "/consumed_energy.dat");
+	energy_file = fopen(energy, "a");
+	
+	fprintf(energy_file, "%.3f\n", consumed_energy);
+	fclose(energy_file);
+
+	/* imprime em arquivo as msg enviadas */
+	FILE * negotiation_msgs_file;
+	
+	strcat(negotiation_msgs, "/negotiation_msgs_sent.dat");
+	negotiation_msgs_file = fopen (negotiation_msgs, "a");
+	
+	fprintf(negotiation_msgs_file, "%d\n", negotiation_msgs_sent);
+	fclose(negotiation_msgs_file);
+}
+
diff -rupN ns-allinone-2.35-orig/ns-2.35/mannasim/util/accounts.h ns-allinone-2.35/ns-2.35/mannasim/util/accounts.h
--- ns-allinone-2.35-orig/ns-2.35/mannasim/util/accounts.h	1970-01-01 01:00:00.000000000 +0100
+++ ns-allinone-2.35/ns-2.35/mannasim/util/accounts.h	2009-11-12 15:43:11.000000000 +0100
@@ -0,0 +1,96 @@
+///  
+/// Copyright (C) 2003-2005 Federal University of Minas Gerais
+/// 
+/// This program is free software; you can redistribute it and/or
+/// modify it under the terms of the GNU General Public License
+/// as published by the Free Software Foundation; either version 2
+/// of the License, or (at your option) any later version.
+/// This program is distributed in the hope that it will be useful,
+/// but WITHOUT ANY WARRANTY; without even the implied warranty of
+/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+/// GNU General Public License for more details.
+/// You should have received a copy of the GNU General Public License
+/// along with this program; if not, write to the Free Software
+/// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
+/// MA 02110-1301, USA.
+/// 
+/// 
+/// authors: Helen Peters de Assunção
+/// 		 Carlos Eduardo R. Lopes
+///
+/// 
+///
+/// --
+/// The Manna Reseach Group
+/// e-mail: mannateam@gmail.com
+///
+/// This project was financially supported by The National Council 
+/// for Scientific and Technological Development (CNPq) from the 
+/// brazilian government under the process number 55.2111/2002-3.
+///
+#ifndef __accounts__
+#define __accounts__
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string>
+
+/* 
+ * Classe com vari�veis que 
+ * contabilizam as m�tricas 
+ * avaliadas 
+ * 
+ */
+
+/* ATEN��O: MUDARA QUANDO MUDAR O SCRIPT */
+#define NUMERO_NOS_COMUNS 48
+#define NUMERO_CLUSTER_HEADS 4
+
+class Accounts
+{
+	public:
+
+		//retorna a inst�ncia �nica
+		Accounts * instance();
+
+		void incr_sent_msgs();
+
+		void incr_negotiation_msgs();
+			
+		void incr_nodes(int number_of_nodes);
+		
+		void incr_nodes_per_group(int number_of_nodes);
+
+		void incr_energy_consumption(double consumption);
+			
+		void print_accounts(char * output_dir);
+		
+	protected:
+	
+		Accounts();
+			
+	private:
+
+		/// Accounts the number of management messages sent
+		/// by the node.
+		int management_msgs_sent;
+
+		/// Accounts the number of negotiation messages sent
+		/// by the node.
+		int negotiation_msgs_sent;
+
+		/// Accounts the number of nodes that have a father, 
+		/// the other nodes are orphans.
+		int nodes;
+
+		/// Average number of nodes per group (cluster)
+		int nodes_per_group;
+		
+		/// Number of groups (cluster) in the network.
+		int groups_counter;
+			
+		/// Cosumed energy with cluster head processing
+		double consumed_energy;
+};
+
+#endif
diff -rupN ns-allinone-2.35-orig/ns-2.35/tcl/lib/ns-default.tcl ns-allinone-2.35/ns-2.35/tcl/lib/ns-default.tcl
--- ns-allinone-2.35-orig/ns-2.35/tcl/lib/ns-default.tcl	2009-06-14 19:35:41.000000000 +0200
+++ ns-allinone-2.35/ns-2.35/tcl/lib/ns-default.tcl	2009-11-12 15:43:11.000000000 +0100
@@ -565,6 +565,54 @@ Node/MobileNode set REGAGENT_PORT 0
 Node/MobileNode set DECAP_PORT 1
 
 
+# -----------------------------------------------------------------------------
+# Inserted by The Manna Research Group
+# Default values used by mannasim - wireless sensor networks simulator.
+# -----------------------------------------------------------------------------
+
+#DataGenerator set sensing_interval_ 0.0
+#DataGenerator set sensing_type_ 0
+
+DataGenerator/TemperatureDataGenerator set sensing_interval_ 0.0
+DataGenerator/TemperatureDataGenerator set sensing_type_ 0
+DataGenerator/TemperatureDataGenerator set avg_measure 25.0
+DataGenerator/TemperatureDataGenerator set std_deviation 1.0
+DataGenerator/TemperatureDataGenerator set maximumTemperatureValue 00.0
+
+DataGenerator/CarbonMonoxideDataGenerator set sensing_interval_ 0.0
+DataGenerator/CarbonMonoxideDataGenerator set sensing_type_ 0
+DataGenerator/CarbonMonoxideDataGenerator set avg_measure 3000.0
+DataGenerator/CarbonMonoxideDataGenerator set std_deviation 100.0
+DataGenerator/CarbonMonoxideDataGenerator set maximumCarbonMonoxideValue 0.0
+
+Application/SensorBaseApp set disseminating_type_ 0
+Application/SensorBaseApp set disseminating_interval_ 0.0
+Application/SensorBaseApp set destination_id_ 0
+
+Application/SensorBaseApp/CommonNodeApp set disseminating_type_ 0
+Application/SensorBaseApp/CommonNodeApp set disseminating_interval_ 0.0
+Application/SensorBaseApp/CommonNodeApp set destination_id_ 0
+
+Node/MobileNode/SensorNode set sensingPower_ 0.5
+Node/MobileNode/SensorNode set processingPower_ 0.5
+Node/MobileNode/SensorNode set instructionsPerSecond_ 100000000
+
+Application/AccessPointApp set outside_network_ 0
+Application/AccessPointApp set request_type_ 0
+Application/AccessPointApp set destination_id_ 0
+Application/AccessPointApp set node_id_ 0
+Application/AccessPointApp set diretorio 0
+
+#Application/SensorBaseApp/ClusterHeadApp/ClusterHeadMannaManagerApp set coverageInterval 0.0
+#Application/SensorBaseApp/ClusterHeadApp/ClusterHeadMannaManagerApp set groupInterval 0.0
+#Application/SensorBaseApp/ClusterHeadApp/ClusterHeadMannaManagerApp set initialGroupInterval 0.0
+#Application/SensorBaseApp/ClusterHeadApp/ClusterHeadMannaManagerApp set WIDTH 0
+#Application/SensorBaseApp/ClusterHeadApp/ClusterHeadMannaManagerApp set HEIGHT 0
+
+# -----------------------------------------------------------------------------
+
+
+
 # Default settings for Hierarchical topology
 #
 # Bits are allocated for different fields like port, nodeid, mcast, 
diff -rupN ns-allinone-2.35-orig/ns-2.35/tcl/lib/ns-lib.tcl ns-allinone-2.35/ns-2.35/tcl/lib/ns-lib.tcl
--- ns-allinone-2.35-orig/ns-2.35/tcl/lib/ns-lib.tcl	2009-06-14 19:35:41.000000000 +0200
+++ ns-allinone-2.35/ns-2.35/tcl/lib/ns-lib.tcl	2009-11-12 15:43:11.000000000 +0100
@@ -337,6 +337,9 @@ Simulator instproc dumper obj {
 # change wrt Mike's code
 #                  -eotTrace OFF
 #                  -diffusionFilter "GradientFilter/OnePhasePullFilter/GeoRoutingFilter/RmstFilter/SourceRouteFilter/LogFilter/TagFilter"
+#
+# add by The Manna Research Group
+#                  -sensorNode ON
 
 
 Simulator instproc addressType  {val} { $self set addressType_  $val }
@@ -386,6 +389,8 @@ Simulator instproc rtAgentFunction {val}
 # change wrt Mike's code
 Simulator instproc eotTrace  {val} { $self set eotTrace_  $val }
 Simulator instproc diffusionFilter {val} {$self set diffFilter_ $val}
+# Inserted by The Manna Research Group; For Mannasim; inserted by Christian Schultz
+Simulator instproc sensorNode {val} {$self set sensorNode_ $val}
 
 Simulator instproc MPLS { val } { 
 	if { $val == "ON" } {
@@ -769,11 +774,28 @@ Simulator instproc create-wireless-node 
 	return $node
 }
 
+# Simulator instproc create-node-instance args {
+#	$self instvar routingAgent_
+#	# DSR is a special case
+#	if {$routingAgent_ == "DSR"} {
+#		set nodeclass [$self set-dsr-nodetype]
+#	} else {
+#		set nodeclass Node/MobileNode
+#	}
+#	return [eval new $nodeclass $args]
+# }
+
+
+# Inserted by The Manna Research Group
+# Used by mannasim - wireless sensor network simulator
 Simulator instproc create-node-instance args {
-	$self instvar routingAgent_
+    $self instvar routingAgent_ sensorNode_
+    
 	# DSR is a special case
 	if {$routingAgent_ == "DSR"} {
 		set nodeclass [$self set-dsr-nodetype]
+    } elseif { [info exists sensorNode_] && $sensorNode_ == "ON"} {
+        set nodeclass Node/MobileNode/SensorNode
 	} else {
 		set nodeclass Node/MobileNode
 	}
